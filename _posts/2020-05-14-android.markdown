---
layout: post
title: android
date: 2020-05-14 12:00:00.000000000 +08:00
---

#### 关于Android的使用心得

这里存放了一些觉得不错的python项目和python的学习到的东西

##### 一些自己认为不错的项目
> [jumpserver审计4A堡垒机](https://github.com/jumpserver/jumpserver)
remote App（远程访问控制）
会话管理
会话录像
文件管理
SSH登陆
脚本下发
定时改密计划

##### 从命令行构建您的应用
https://developer.android.google.cn/studio/build/building-cmdline?hl=zh_cn

##### smali语法
smali是什么, 官方的简介

smali/baksmali is an assembler/disassembler for the dex format used by dalvik, Android’s Java VM implementation. The syntax is loosely based on Jasmin’s/dedexer’s syntax, and supports the full functionality of the dex format (annotations, debug info, line info, etc.)
smali / baksmali是Android的Java VM实现dalvik使用的dex格式的汇编程序/反汇编程序。语法松散地基于Jasmin的/ dedexer的语法，并支持dex格式的全部功能（注释，调试信息，行信息等）

Java代码

public int show(String str){
    return 1;
}
smali代码

# virtual methods
.method public show(Ljava/lang/String;)I
    .locals 1
    .param p1, "str"    # Ljava/lang/String;

    .line 22
    const/4 v0, 0x1

    return v0
.end method
数据类型 / 对象 / 数组 的写法, 对于经常JNI开发的童鞋肯定非常熟悉, 没错, 跟javap生成签名类型是一样的.

数据类型
smali类型 java类型  Description
V void (用于返回类型) -
Z boolean 不同
B byte  -
S short -
C char  -
I int -
J long (64 bits)  不同
F float -
D double (64 bits)  -
运算
smali

mul-int v0, p1, p2
1
add-int / add-long / add-float / add-double / add-int/lit16 / add-int/lit8

smali运算符  Description int long  float double
add-int v0, p1, p2  v0 = p1 + p2  √ √ √ √
sub-int v0, p1, p2  v0 = p1 - p2  √ √ √ √
mul-int v0, p1, p2  v0 = p1 * p2  √ √ √ √
div-int v0, p1, p2  v0 = p1 / p2  √ √ √ √
rem-int v0, p1, p2  v0 = p1 % p2  √ √ √ √
and-int v0, p1, p2  v0 = p1 & p2  √ √ × ×
or-int v0, p1, p2 v0 = p1 │ p2  √ √ × ×
xor-int v0, p1, p2  v0 = p1 ^ p2  √ √ × ×
shl-int v0, p1, p2  v0 = p1 << p2 √ √ × ×
shr-int v0, p1, p2  v0 = p1 >> p2 √ √ × ×
ushr-int v0, p1, p2 v0 = p1 >>> p2  √ √ × ×
add-int/2addr v0, v1  v0 = v0 + v1  √ √ √ √
sub-int/2addr v0, v1  v0 = v0 - v1  √ √ √ √
mul-int/2addr v0, v1  v0 = v0 * v1  √ √ √ √
div-int/2addr v0, v1  v0 = v0 / v1  √ √ √ √
rem-int/2addr v0, v1  v0 = v0 % v1  √ √ √ √
and-int/2addr v0, v1  v0 = v0 & v1  √ √ × ×
or-int/2addr v0, v1 v0 = v0 │ v1  √ √ × ×
xor-int/2addr v0, v1  v0 = v0 ^ v1  √ √ × ×
shl-int/2addr v0, v1  v0 = v0 << v1 √ √ × ×
shr-int/2addr v0, v1  v0 = v0 >> v1 √ √ × ×
ushr-int/2addr v0, v1 v0 = v0 >>> v1  √ √ × ×
add-int/lit16 v0, v1, lit16 v0 = v1 + lit16 √ × × ×
sub-int/lit16 v0, v1, lit16 v0 = v1 - lit16 √ × × ×
mul-int/lit16 v0, v1, lit16 v0 = v1 * lit16 √ × × ×
div-int/lit16 v0, v1, lit16 v0 = v1 / lit16 √ × × ×
rem-int/lit16 v0, v1, lit16 v0 = v1 % lit16 √ × × ×
and-int/lit16 v0, v1, lit16 v0 = v1 & lit16 √ × × ×
or-int/lit16 v0, v1, lit16  v0 = v1 │ lit16 √ × × ×
xor-int/lit16 v0, v1, lit16 v0 = v1 ^ lit16 √ × × ×
add-int/lit8 v0, v1, lit8 v0 = v1 + lit8  √ × × ×
sub-int/lit8 v0, v1, lit8 v0 = v1 - lit8  √ × × ×
mul-int/lit8 v0, v1, lit8 v0 = v1 * lit8  √ × × ×
div-int/lit8 v0, v1, lit8 v0 = v1 / lit8  √ × × ×
rem-int/lit8 v0, v1, lit8 v0 = v1 % lit8  √ × × ×
and-int/lit8 v0, v1, lit8 v0 = v1 & lit8  √ × × ×
or-int/lit8 v0, v1, lit8  v0 = v1 │ lit8  √ × × ×
xor-int/lit8 v0, v1, lit8 v0 = v1 ^ lit8  √ × × ×
shl-int/lit8 v0, v1, lit8 v0 = v1 << lit8 √ × × ×
shr-int/lit8 v0, v1, lit8 v0 = v1 >> lit8 √ × × ×
ushr-int/lit8 v0, v1, lit8  v0 = v1 >>> lit8  √ × × ×
类名
smali类名 java类名
Ljava/lang/String;  java.lang.String
Ljava/lang/Object;  java.lang.Object
L全/类/名; 全.类.名
smali类名写法要注意, 最前面L开头, 最后;结尾

数组
smali数组 Java数组
[I  int[]
[[I int[][]
[Ljava/lang/String; String[]
… …
smali数组在类型左侧加[号, 几维就加几个, 最多255维.

类的定义
Java代码

public class BaseData {
    public int add(int x, int y){
        return x * y;
    }
}
4
5
Smali代码

.class public Lme/luzhuo/smalidemo/BaseData; // 本类
.super Ljava/lang/Object; // 父类
.source "BaseData.java" // 文件名


# direct methods
// 构造方法, 方法名为<init>
.method public constructor <init>()V
    .locals 0

    .line 20
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method


# virtual methods
// 普通方法 / add:方法名 / II:返回类型 / I:返回类型
.method public add(II)I
    .locals 1
    .param p1, "x"    # I  // 参数
    .param p2, "y"    # I

    .line 26 // 该函数在原.source中的位置(含注释)
    mul-int v0, p1, p2

    return v0
.end method
类的定义: 本类 / 父类 / 文件名

.class public Lme/luzhuo/smalidemo/BaseData; // 本类
.super Ljava/lang/Object; // 父类
.source "BaseData.java" // 文件名
属性的定义: 属性名 / 属性类型

# static fields
// 属性: .field 修饰符 属性名:属性类型
.field private static final TAG:Ljava/lang/String; = "PropActivity"
方法的定义: 方法名 / 参数类型 / 参数名 / 返回类型 / 返回值

// 方法: .method 修饰符 方法名(参数类型)返回类型
.method public add(II)I
    .locals 1
    .param p1, "x"    # I  // 参数名
    .param p2, "y"    # I

    return v0  // 返回值
.end method
返回指令  Description
return-void 直接返回
return v0 返回v0
return-object v0  返回v0(对象)
return-wide v0  给v0(双寄存器的值)
特殊的方法:

// 构造方法
.method public constructor <init>()V
.end method

// 静态方法
.method public static final constructor <clinit>()V
.end method
4
5
6
7
调用方法:

const/4 v0, 0x3
const/4 v1, 0x5

// 调用方法: 类->方法
invoke-virtual {p0, v0, v1}, Lme/luzhuo/smalidemo/BaseData;->add(II)I
4
5
调用指令  Description 案例
invoke-virtual  调用一般方法  invoke-virtual {p0, v0, v1}, Lme/luzhuo/smalidemo/BaseData;->add(II)I
invoke-super  调用父类方法  invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;->onCreate(Landroid/os/Bundle;)V // super.onCreate(savedInstanceState);
invoke-direct 调用private/构造方法  invoke-direct {p0}, Ljava/lang/Object;-><init>()V
invoke-static 调用静态方法  invoke-static {}, Lme/luzhuo/smalidemo/BaseData;->aaa()V
invoke-interface  调用interface方法 invoke-interface {v0}, Lme/luzhuo/smalidemo/Inter;->mul()V
寄存器
方法内部先声明寄存器数量, 然后再写代码

.method public add(II)I
    .locals 1
    .param p1, "x"    # I
    .param p2, "y"    # I

  // 先完成上面部分的声明, 然后在这些代码
    .line 26
    mul-int v0, p1, p2

    return v0
.end method
11
寄存器的声明方式

.locals 0  // 声明不算参数, 需要加几个寄存器
.registers 0  // 声明算上参数, 一共需要几个寄存器
寄存器命名规则

v0 v1 v2 v... // .locals 寄存器的命名
p0 p1 p2 p... // .registers 寄存器的命名
.registers不用声明, .locals要声明
有参数, 用p表示第几个参数所占的寄存器, 从1开始

给寄存器赋值:
const/4 v0, 0x3
const-string v0, "\u4f60\u88ab\u6211\u53cd\u7f16\u8bd1\u5566\u002c\u0020\u54c8\u54c8\u54c8\u54c8"
常量指令  Description 案例
const(/4, /16, ,/high16) vx, num  把nun赋给vx寄存器, num为(4bit, 16bit, 32bit(int), 16bit(float))  const v0, 0x3
const-wide(/16, ,/high16) vx, num 把num赋给vx和vx+, num为(?, 64bit(long), 64bit(double)) const-wide v0, 0x123456L
const-string( , -jumbo) vx, string  "Unicode"字符串赋给vx (一般, 过长) const-string v0, "\u4f60\u88ab..."
const-class vx, class 将Class赋值给vx const-class v0, LJava/lang/String;
boolean
用const/4赋值, 1true, 0false
float/double
用0x16进制表示小数
long和double的16进制数后加L
// smali 给寄存器赋值, 并起名(带名称的常量)
const/16 v0, 0xa
.local v0, "a":I

// java
int a = 0xa;

// ---

// smali 给寄存器赋值对象
const/4 v2, 0x0
new-array v2, v2, [Ljava/lang/String;

// java
new String[]
值的判断指令
// smali
const/16 v0, 0xa
const/16 v1, 0x14

if-le v0, v1, :cond_0

const/16 v0, 0x1e

goto :goto_0

:cond_0
const/16 v1, 0x1e

:goto_0


// java
if (v0 <= v1) {
  cond_0
}else{
  const/16 v0, 0x1e
  goto_0
}
// 翻译成人话: 等式不成立则往下执行
// java中写 a > b, 到这里就相反, 变成 a <= b 了.
指令  Description
if-eq v0, v1, :cond_0 if (v0 == v1) cond_0
if-ne v0, v1, :cond_0 if (v0 != v1) cond_0
if-gt v0, v1, :cond_0 if (v0 > v1) cond_0
if-ge v0, v1, :cond_0 if (v0 >= v1) cond_0
if-lt v0, v1, :cond_0 if (v0 < v1) cond_0
if-le v0, v1, :cond_0 if (v0 <= v1) cond_0
if-eqz v0, :cond_0  if (v0 == 0) cond_0
if-nez v0, :cond_0  if (v0 != 0) cond_0
if-gtz v0, :cond_0  if (v0 > 0) cond_0
if-gez v0, :cond_0  if (v0 >= 0) cond_0
if-ltz v0, :cond_0  if (v0 < 0) cond_0
if-lez v0, :cond_0  if (v0 <= 0) cond_0
移位指令
smali

.method public show()I
    const/16 v0, 0xa
    const/16 v1, 0x14
    const/4 v2, 0x0
    new-array v2, v2, [Ljava/lang/String;

    invoke-virtual {p0, v0, v1, v2}, Lme/luzhuo/smalidemo/BaseData;->add(II[Ljava/lang/String;)I

    move-result v2

    return v2
.end method
移位指令  Description
move( , /from16, /16) v0, v1  将v1值移入到v0(4bit(int), 16bit->8bit, 16bit)
move-wide( , /from16, /16) v0, v1 将v1值移入到v0(4bit, 16bit->8bit, 16bit)
move-object( , /from16, /16) v0, v1 将v1对象指针移入到v0(4bit, 16bit->8bit, 16bit)
move-result( , -object, -wide) v0 将上条指令计算结果, 移入到v0(值, 对象指针, 双寄存器值)
move-exception v0 将异常移入到v0
实例字段指令
smali

.method public static final aaa()V
    .locals 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const-string v1, "sfsdf"
    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
iget / aget / sget: 数字 / 数组 / 静态

实例字段指令  Description
iget  取值(int)
iget-wide 取值(双寄存器值)
iget-object 取值(对象指针)
iget-boolean  取值(bool)
iget-byte 取值(字节)
iget-char 取值(字符)
iget-short  取值(short)
iput  赋值(int)
iput-wide 赋值(双寄存器值)
iput-object 赋值(对象指针)
iput-boolean  赋值(bool)
iput-byte 赋值(字节)
iput-char 赋值(字符)
iput-short  赋值(short)
其他
注解
smali

.method protected onCreate(Landroid/os/Bundle;)V
    .locals 0
    .param p1    # Landroid/os/Bundle;
        .annotation build Landroid/support/annotation/Nullable;
        .end annotation
    .end param

  //...

    return-void
.end method

java

protected void onCreate(Bundle @Nullable savedInstanceState) {
}
创建数组
smali

const/4 v2, 0x0
new-array v2, v2, [Ljava/lang/String;

##### adb命令

```bash
adb pull /sdcard/Android/data/chatpaint.caoliao.net.cn/files/databases/chatpaint_caoliao.db ./

1, adb简介
adb全名Andorid Debug Bridge. 顾名思义, 这是一个Debug工具.
然而, 为何称之为Bridge呢? 因为adb是一个标准的CS结构的工具, 是要连接开发电脑和你的调试手机的.包含如下几个部分:

Client端, 运行在开发机器中, 即你的开发PC机. 用来发送adb命令.
Deamon守护进程, 运行在调试设备中, 即的调试手机或模拟器.
Server端, 作为一个后台进程运行在开发机器中, 即你的开发PC机. 用来管理PC中的Client端和手机的Deamon之间的通信.
2, 常用用法
2.1 adb devices
列举当前连接的调试设备

$ adb devices
List of devices attached
DU2SSE1467010378    device
2.2 adb logcat
打印log信息

指令  说明  备注
adb logcat  打印log   /
adb logcat -c   清除手机的log buffer 有些手机权限控制, 不支持.
adb logcat -b <buffer>  打印指定buffer的log信息    buffer有: main(主log区,默认), events(事件相关的log), radio(射频, telephony相关的log)
adb logcat -v <format>  格式化输出log    常用的用adb logcat -v time显示时间
adb logcat -f <filename>    输出log到指定文件
2.3 adb install/uninstall
安装卸载apk

// 安装apk时指定apk file路径
$ adb install ~/Downloads/mobileqq_android.apk
[100%] /data/local/tmp/mobileqq_android.apk
    pkg: /data/local/tmp/mobileqq_android.apk
Success

adb -s emulatorId

// 卸载apk时指定包名
$ adb uninstall com.tencent.mobileqq
Success
2.4 adb pull/push
调试设备和开发PC之间拷贝文件.

// 拷贝本地文件到调试设备中
$ adb push ~/temp/GithubApp.trace /sdcard/
[100%] /sdcard/GithubApp.trace

// 从调试设备中拷贝文件到本地
$ adb pull /sdcard/GithubApp.trace ~/
adb pull /sdcard/Android/obb/com.xunlei.downloadprovider/ ~/
[100%] /sdcard/GithubApp.trace
2.5 adb start/kill-server
启动/杀死adb简介中提到的Server端进程.

由于adb并不稳定, 有时候莫名的问题掉线时, 可以先kill-server, 然后start-server来确保Server进程启动. 往往可以解决问题.

2.5 adb shell
进入调试设备的shell界面, 此时可以使用调试设备中的很多指令. 下文高阶用法中很多就是.

$ adb shell
shell@hwH60:/ $
3, 高阶用法
3.1 adb connect/disconnect
通过wifi进行远程连接手机进行调试的.
https://developer.android.com/studio/command-line/adb.html#wireless

需先连上usb模式, 开启远程调试模式:
$ adb tcpip 5555

3.2 adb shell am
am即activity manager.
该命令用来执行一些系统动作, 例如启动指定activity, 结束进程, 发送广播, 更改屏幕属性等. 调试利器.

指令  说明  备注
start <Intent>  根据intent指向启动Activity    Intent可以是显示的指向activity, 也可以是ACTION方式, 并且可以添加flag, data等参数信息.
startservice <Intent>   启动Service   可以添加flag, data等参数信息.
broadcast <Intent>  发送广播    可以添加flag, data等参数信息.
monitor 启动一个Crash和ANR的监听器   如有Crash或ANR会在控制台输出相关信息.
force-stop <Package>    强制停止该包相关的一切 传入package name.
kill <Package>  杀死该包相关的所有进程 传入package name.
kill-all    杀死所有后台进程
display-size WxH    改变显示的分辨率    例如adb shell am display-size 1280x720, 手机可能不支持.
display-density <dpi>   改变显示的density    例如adb shell am display-density 320, 手机可能不支持.
3.3 adb shell pm
pm即package manager.


用来执行package相关的操作, 例如安装卸载, 查询系统的安装包等.
如果只是想查看手机上应用的packageName：
adb shell pm list packages
要看一个apk文件的相关信息最简单实用的指令是：
aapt dump badging [yourapp.apk]
如果想知道应用对应的apk文件在手机上的安装位置则可以在上面的命令后加-f参数
adb shell pm list packages -f

指令  说明  备注
list packages <Filter>  列出满足filter条件的所有包
list permissions <Group>    列出该Group的所有权限
list features   查看系统支持哪些feature 例如蓝牙, wifi, 摄像头等.
install <Path>/uninstall <Package>  安装卸载
clear <Package> 清除应用数据
3.4 adb shell screencap
截屏, 比截屏快捷键更加方便快捷.

$ adb shell screencap /sdcard/screen.png

$ adb pull /sdcard/screen.png ~/temp
[100%] /sdcard/screen.png
3.5 adb shell screenrecord
录屏, 做demo的话, 可以很方便的用这个命名录制视频, 然后借助工具将其转换成gif图, 超赞. 如下:

screenrecord gif
Android4.4及以上系统可用.

2.5 adb shell dumpsys
强大的dump工具, 可以输出很多系统信息. 例如window, activity, task/back stack信息, wifi信息等.

探索Activity之launchMode和探索Activity之启动Intent flag和Affinity就是用adb shell dumpsys activity来输出task信息的.

常用dumpsys:

指令  说明  备注  细分参数
activity    输出app组件相关信息 还可以用细分参数获得单项内容, 下同. 例如adb shell dumpsys activity activities来获取activity task/back stack信息.   activites, service, providers, intents, broadcasts, processes
alarm   输出当前系统的alarm信息  /   /
cpuinfo 输出当前的CPU使用情况    /   /
diskstats   输出当前的磁盘使用状态 /   /
batterystats    电池使用信息  /   /
package package相关信息, 相当于pm功能的集合 输出诸如libs, features, packages等信息 /
meminfo 输出每个App的内存使用和系统内存状态 可以指定包名, 例如adb shell dumpsys meminfo com.anly.githubapp  /
window  输出当前窗口相关信息  /   policy, animator, tokens, windows


物理密度
adb shell wm density
设备信息(HUAWEI)
adb shell getprop ro.product.device
android os版本
adb shell getprop ro.build.version.release
像素Physical size: 1080x1920
adb shell wm size
用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来
adb shell screencap -p /sdcard/autojump.png
adb pull /sdcard/autojump.png .
上传图片到手机
adb push /Users/zhangshuai/taobaoPics/1.jpg /storage/emulated/0/Pictures/Screenshots/
抓取logcat
adb  logcat > /Users/zhangshuai/log.txt 
发送广播 （发送刷新目录广播，用于读取新push的图片）
adb shell "find /storage/emulated/0/Pictures/Screenshots/ | while read f; do am broadcast -a android.intent.action.MEDIA_SCANNER_SCAN_FILE -d \"file://${f}\"; done"
adb shell am broadcast -a android.intent.action.MEDIA_SCANNER_SCAN_FOLDER -d file:///storage/emulated/0/Pictures/Screenshots
adb shell am broadcast -a android.intent.action.MEDIA_SCANNER_FINISHED -d file:///storage/emulated/0/Pictures/Screenshots/
adb shell am broadcast -a android.intent.action.MEDIA_SCANNER_SCAN_FILE -d file:///storage/emulated/0/Pictures/Screenshots/1.jpg


滑动
adb shell input swipe x y x1 y1 time(ms)


1. 显示系统中全部Android平台：
    android list targets
    2. 显示系统中全部AVD（模拟器）：
    android list avd
    3. 创建AVD（模拟器）：
    android create avd --name 名称 --target 平台编号
    4. 启动模拟器：
    emulator -avd 名称 -sdcard ~/名称.img (-skin 1280x800)
    5. 删除AVD（模拟器）：
    android delete avd --name 名称
    6. 创建SDCard：
    mksdcard 1024M ~/名称.img
    7. AVD(模拟器)所在位置：
    Linux(~/.android/avd)      Windows(C:\Documents and Settings\Administrator\.android\avd)
    8. 启动DDMS：
    ddms
    9. 显示当前运行的全部模拟器：
    adb devices
    10. 对某一模拟器执行命令：
      abd -s 模拟器编号 命令
      11. 安装应用程序：
      adb install -r 应用程序.apk
      12. 获取模拟器中的文件：
      adb pull <remote> <local>
      13. 向模拟器中写文件：
      adb push <local> <remote>
      14. 进入模拟器的shell模式：
      adb shell
      15. 启动SDK，文档，实例下载管理器：
      android
      16. 缷载apk包：
      adb shell
            cd data/app
            rm apk包
            exit
            adb uninstall apk包的主包名
            adb install -r apk包
            17. 查看adb命令帮助信息：
      adb help
      18. 在命令行中查看LOG信息：
      adb logcat -s 标签名
      19. adb shell后面跟的命令主要来自：
      源码\system\core\toolbox目录和源码\frameworks\base\cmds目录。
      20. 删除系统应用：
      adb remount （重新挂载系统分区，使系统分区重新可写）。
            adb shell
            cd system/app
            rm *.apk
            21. 获取管理员权限：
      adb root
      22. 启动Activity：
      adb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）。
      23、发布端口：
    你可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如： 
adb forward tcp:5555 tcp:8000
24、复制文件：
    你可向一个设备或从一个设备中复制文件， 
     复制一个文件或目录到设备或模拟器上： 
  adb push <source> <destination></destination></source      如：adb push test.txt /tmp/test.txt 
     从设备或模拟器上复制一个文件或目录： 
     adb pull <source> <destination></destination></source     如：adb pull /addroid/lib/libwebcore.so .
     25、搜索模拟器/设备的实例：
     取得当前运行的模拟器/设备的实例的列表及每个实例的状态： 
    adb devices
    26、查看bug报告： 
adb bugreport 
27、记录无线通讯日志：
    一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录： 
    adb shell 
    logcat -b radio
    28、获取设备的ID和序列号：
     adb get-product 
     adb get-serialno
     29、访问数据库SQLite3
     adb shell 
     sqlite3
#cd system/sd/data //进入系统内指定文件夹 
#ls //列表显示当前文件夹内容 
#rm -r xxx //删除名字为xxx的文件夹及其里面的所有文件 
#rm xxx //删除文件xxx 
#rmdir xxx //删除xxx的文件夹
```

##### gradle


gradle运行，编译android项目，安装apk（操作出处react-native0.57.8 local-cli/reactAndroid/runAndroid.js）

(window 下使用 gradlew.bat)./gradlew installDebug
gradlew build -x lint //buildApk
adb install `${args.appFolder}/build/outputs/apk/${args.appFolder}-debug.apk`;
adb shell am start -n `${packageNameWithSuffix}/${packageName}.MainActivity`

graldew 常用命令
gradlew -q dependencies app:dependencies 查看依赖引用结构(android{buildTypes {debug {minifyEnabled true}}} // 解决Error: Program type already present: xxx)

gradlew compileDebug --stacktrace 编译错误详查（点击Android studio build控制台toggle view按钮同样结果）

APPT resource无法识别错误，android studio中可以引用到资源文件（更新 minSdkVersion 27）


Download https://services.gradle.org/distributions/gradle-5.4.1-all.zip Running for 1 m 21 s
下载失败，卡住不动
手动下载下来 保存到
/Users/xiaoyu/.gradle/wrapper/dists/xxx 对应版本文件夹中

android studio 报错处理
mips64el-linux-android-strip 找不到（升级gradle 3.1.0可以解决）
https://blog.csdn.net/bylaven/article/details/80331345


1.找到项目中引用的版本是否自己写的版本冲突
2.在app模块中强制使用制定版本解决冲突（build.gradle文件[最外层]）

subprojects {
    project.configurations.all {
        resolutionStrategy.eachDependency { details ->
            if (details.requested.group == 'androidx.core:core'
                    && !details.requested.name.contains('androidx') ) {
                details.useVersion "1.1.0-alpha05"
            }
        }
    }
}


依赖xxx版本非指定版本（依赖的lib中有依赖xxx的，版本不同，导致出现多个xxx版本，应用使用了最低版本）
command + shift + f 搜索只在低版本中拥有的类，查找依赖的lib(更新lib或删除或工程降级)
greendao
squareup.Retrofit


下载gradle依赖资源存储路径为
/Users/xiaoyu/.gradle/caches/modules-2/files-2.1
整理完正确资源版本后，将jar包aar包 copy 到 lib目录，注释implement资源。可以跳过下载过程。但是gradle metadata过程依然会继续 1min左右时间

加速资源访问（常用镜像）

        maven { url 'https://dl.bintray.com/umsdk/release' }
        maven {
            url 'https://maven.google.com'
        }
        maven {url 'http://developer.huawei.com/repo/'}
        maven {
            url 'http://maven.aliyun.com/nexus/content/repositories/releases/'
        }
//        maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}
        google()
        jcenter()
        mavenCentral()


～～～
        maven { url 'https://dl.bintray.com/umsdk/release' }
        maven {url 'http://developer.huawei.com/repo/'}
//        maven{url 'http://maven.aliyun.com/nexus/content/groups/public/'}

        maven {
            url 'http://maven.aliyun.com/nexus/content/repositories/releases/'
        }
        maven {
            url 'https://maven.google.com/'
            name 'Google'
        }

        google()
        maven {
            url 'https://maven.google.com'
        }
        jcenter()
        maven { url "https://jitpack.io" }
        maven { url "https://dl.bintray.com/thelasterstar/maven/" }//新浪微博SDK
        maven {
            // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
            url "$rootDir/../node_modules/react-native/android"
        }

> 命令详情

AppExtension的方法： 
- flavorDimensions(dimension):指定flavor名称 
- useLibraray(name)：请求使用一个lib库 
- useLibrary(name,required)：与上面解释一样。


AaptOptions的属性：
1.additionalParameters:额外参数，List类型。
2.cruncherEnabled：如果PNG图片是否可以大量快速的处理，boolean类型。 true表示可以。
3.cruncherProcesses:快速处理，可能需要更多的内存和CPU。int类型。默认0，值越大处理越快，需要的内存和CPU也越大。
4.failOnMissingConfigEntry:如果没有找到一个配置，就返回一个错误。Boolean值，默认false。
5.ignoreAssetsPattern：忽略Assets模块。
6.moCompress：拓展文件不会打包进apk中。


用法(详细用法可能需要去看看文档了)：

aaptOptions{
    cruncherEnabled true//快速处理PNG图片
}

AdbOptions的属性：
1.installOptions：apk安装的可选参数。
2.timeOutInMs：使用adb的超时时间。


CompileOptions的属性：
1.encoding：Java源文件的编码格式
2.incremental：是否应该使用Java编写的Gradle新的增量模型
3.sourceCompatibility：指定编译编译.java文件的jdk版本
4.targetCompatibility：确保class文件与targetCompatibility指定版本，或者更新的java虚拟机兼容


DataBindingOptions的属性：
1.addDefualtAdapters：是否添加一个默认的data binding适配器。默认true。
2.enabled：是否使用data binding
3.version：data binding使用版本


defaultConfig的使用：

defaultConfig {
        applicationId "com.example.zhang.demo"
        minSdkVersion 15
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
}



dexOptions{}
dexOptions{}对应的是DexOptions

DexOptions属性:

1.additionalParameters：给dx添加一系列附加的参数
2.javaMaxHeapSize：当调用dx时指定-Xmx值。
3.jumboMode：使用jumbo(庞大的)模式
4.keepRuntimeAnnotatedClasses：保持所有类中的运行时的注解在主Dex中。
5.maxProcessCount：可以使用Dex的最大并发进程数。默认为4。
6.optimize：运行在dx编译器是否有optimize标记。
7.preDexLibraries：是否预先dex库，它可以改善增量的生成，但是在clear build可能会变慢
8.threadCount：当dx运行时使用的线程的数量。默认4个。


dexOptions{}的用法：

dexOptions {
    preDexLibraries  false
    javaMaxHeapSize "4g"
}

externalNativeBuild{}
externalNativeBuild{}对应的是ExternalNativeBuild

ExternalNativeBuild的属性：

1.cmake：CMake工具编译选项。
2.ndkBuild：ndk-build选项。


在externalNativeBuild{}中有2个模块，cmake{}和ndkBuild{}模块


cmake{}对应的是CmakeOptions

CmakeOption的属性：
1.path：你的CmakeLists.txt编译脚本的相对路径。

--
ndkBuild{}对应的是NdkBuildOptions

NdkBuildOptions的属性：
1.path:你的Android.mk文件的相对路径。

--


externalNativeBuild{}的用法：

externalNativeBuild{
    ndkBuild{
        path file("src\\main\\jni\\Android.mk")
    }

    cmake {
        path "src/main/cpp/CMakeLists.txt"
    }
}

Android Studio2.2 配置NDK

Android studio 2.2 使用cmake编译NDK

jacoco{}
jacoco{}对应于JacocoOptions

JacocoOptions的属性：
1.version：过时

英文原文：
note: this property is deprecated and will be removed in a future version of the plugin.


packagingOptions{}
packagingOptions{}对应的是PackagingOptions

Packaging options有三组路径：first-picks，merges和excludes:


packagingOptions{}的用法：

packagingOptions {
    pickFirsts = [] // Not really needed because the default is empty.
    merges = []     // Not really needed because the default is empty.
    excludes = []
}

PackagingOptions官方文档

sourceSets{}
sourceSets{}对应的AndroidSourceSet

AndroidSourceSet的属性：

1.aidl：aidl目录
2.assets：assets目录
3.compileConfiguraName：编译配置资源目录。
4.java：java代码目录（需要编译成.class文件）
5.jni：jni资源目录
6.jniLibs：jni库目录
7.manifest：AndroidManifest.xml资源文件
8.name：source set名称。
9.packageConfigurationName：运行时配置的资源集。
10.providedConfigurationName：仅仅编译时配置的资源集。
11.renderscript：RenderScript脚本资源目录
12.res：Android资源目录
13.resource：java资源被复制到输出到javaresource目录


AndroidSourceSet的方法：
1.setRoot(path)：资源集的根目录，所有的资源都在这个跟目录下。


sourceSets{}的使用：

sourceSets {
    //在main目录中
    main {
        //assets目录设置
        assets.srcDirs = ['assets']
        //jni目录设置
        jni.srcDirs 'src/main/jni'
        //jni库设置
        jniLibs.srcDir 'src/main/jniLibs'
    }
}

splits{}
splits{}对应的是Splites

Splits的属性：

1.abi：ABI设置
2.abiFilters：用于多个apk的ABI筛选列表
3.density：密度设置
4.densityFilters：用于多个apk的密度筛选列表
5.language：语言设置。
6.languageFilters：用于多个apk的语言筛选列表

-----


Spiltes对应有三个模块，abi{},density{},language{}


abi{}对应的是AbiSplitOptions

AbiSplitsOptions的属性：
1.applicableFilters：返回此范围的所有适用筛选器的列表。
2.enable：是否在这个范围分裂
3.universalApk：是否创建所有可用的ABIs一个APK。


AbiSplitesOptions的方法：
1.exclude(excludes)：排除一些值。
2.include(include)：包含一些值。
3.reset()：重新设置split配置。

---

density{}对应的是DensitySplitOptions

DensitySplitOptions的属性：
1.applicableFilters：返回此范围的所有适用筛选器的列表。
2.auto：编译系统是否确定分割“language-*”文件夹中的资源。
3.compatibleScreen：兼容屏幕列表
4.enable：是否拆分


DensitySplitOptions的方法：
1.exclude(exclude):排除一些值
2.include(include):包含一些值
3.reset()：重新设置split配置。




language{}对应的是LanguageSplitOptions

LanguageSplitOptions的属性：
1.enable：如果true，就是拆分language


LanguageSplitOptions的方法：
1.include(include)：包含一个模型。



splits{}的用法：

splits {
    density {
        enable true
        exclude 'ldpi', 'mdpi'
        compatibleScreens 'normal', 'large', 'xlarge'
    }
} 

生成结果：
app-hdpi-release.apk
app-universal-release.apk
app-xhdpi-release.apk
app-xxhdpi-release.apk
app-xxxhdpi-release.apk

splits {
    abi {
      enable true
      reset()
      include 'x86', 'armeabi-v7a', 'mips'
      universalApk true
    }
}

这个就是生成不同手机架构的app

APK-splite官方文档

Splite官方文档

参考文章

testOptions{}
testOptions{}对应的是TestOptions

TestOptions的属性：
1.reportDir：报告目录
2.resultDir：结果目录
3.unitTests：单元测试配置参数

TestOptions包含unitTests{}



unitTests{}对应的是UnitTestOptions

UnitTestOptions的属性：
1.returnDefaultValues：无论unmocked方法从android.jar中抛出异常或是默认值（0或null）。


UnitTestOtions的方法：
all(configClosure)：配置所有单元测试任务。

-

testOptions{}的使用：

testOptions {
    resultsDir = "$project.buildDir/foo/results"
}

https://blog.csdn.net/qq_33689414/article/details/53152212 

AndroidStudio右侧的一个Gradle按钮，会打开一个面板。展示所有任务，点击将会运行该任务。
app:clean     移除所有编译文件
app:build     构建app module，执行check,assemble任务
app:check     lint检测
app:assemble  打包，编译出release和debug包 gradlew assembleRelease / gradlew assembleDebug 单独编译命令
app:install   安装包， gradlew installDebug / gradlew installRelease
app:uninstallAll 卸载包，gradlew uninstallDebug / gradlew uninstallRelease


android {

  lint检查 
  lintOptions {
    abortOnError false
LintOptions的属性：
1.abortOnError：如果发现错误，lint工具是否应该退出这个程序。true表示退出。
2.absolutePaths：是否在输出错误的时候，lint应该展示出全路径。默认是相对路径，也就是默认false。
3.check：精确的检查(搜集)问题的集合，默认情况下，任何问题都可以通过LintOptions.getEnable()启用，没有问题可以通过LintOptions.getDisable()使之无效。
4.checkAllWarnings：是否检查所有警告，包括那些默认关闭。
5.disable：通过id's来压制这个问题，允许修改
6.enable：通过id's来处理这个问题，循序修改，他会将添加id，并返回一个集合。
7.explainIssues：返回lint是否包含错误问题的解释(注意：HTML和XML报告会无条件的去做，忽略这个设置)。
8.htmlOutput：html输出方式。
9.htmlReport：我们应该是否写一个HTML报告，默认true， 这个使用场景由LintOptions.getHtmlOutput()控制。
10.ignoreWarings：lint仅仅检查错误，忽略警告。
11.lintConfig：默认配置文件作为备份。
12.noLines：lint在输出错误日志的时候，是否包含行数。默认true。
13.quiet：lint是否应该quiet(安静)。如：报告文件写入路径，不写消息。
14.severityOverrides：An optional map of severity overrides. The map maps from issue id's to the corresponding severity to use, which must be "fatal", "error", "warning", or "ignore".
15.showAll：lint是否包含所有的输出。
16.textOutput：文本输出方式。
17.textReport：是否是文本报告写入，默认false。
18.warningAsErrors：lint是否把警告当做错误来处理。
19.xmlOutput：XML输出方式。
20.xmlReport：XML格式写入报告，默认true。



LintOptions的方法：

1.check(id)：检查这个id的问题的集合
2.check(ids)：
3.disable(id)：将id添加到不用启动的问题集
4.disable(ids)：
5.enable(id)：将id添加到启动的问题集
6.enable(ids)
7.error(id)：将id添加到错误的问题集
8.error(ids)
9.fatal(id)：将id添加到fatal级别的问题集
10.fatal(ids)
11.ignore(id)：将id添加到ignore级别的问题集
12.ignore(ids)
13.waring(id)：将id添加到waring级别的问题集
14.waring(ids)



  }

  定义了编译类型
  buildTypes {
    release {
      minifyEnabled true

buildTypes的属性：

1.applicationIdSuffix：应用id后缀(给Applica)
2.consumerProguardFiles：混淆文件包含在arr包中。
3.debuggable：是否生成一个debug的apk
4.embedMicroApp：可穿戴设备app是否可以使用这个编译类型
5.javaCompileOption：Java编译配置参数
6.jniDebuggable：这个编译类型的配置是否可以与debuggable的native代码生成一个apk
7.manifestPlaceholders：清单占位符
8.minifyEnabled：是否缩小
9.multiDexEnabled：是否拆成多个Dex
10.multiDexKeepFile：指定文本文件编译进主Dex文件中
11.multiDexKeepProguard：指定混淆文件编译进主Dex文件中
12.name：build type的名字
13.proguardFiles：混淆文件
14.pseudoLocalesEnabled：是否生成伪现场apk(如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt）)
15.renderscriptDebuggable：使用RenderScript编译器的优化级别。
16.shrinkResources：是否去除未利用的资源，默认false，表示不去除。
17.signingConfig：签名配置
18.testCoverageEnabled：测试覆盖率是否被激活。
19.useJack：过时
20.versionNameSuffix：版本名称后缀
21.zipAlignEnable：是否使用zipalign工具压缩。


buildType的方法：

1.buildConfigField(type,name,value)：添加一个变量生成BuildConfig类。
2.consumeProguardFile(proguardFile)：添加一个混淆文件进arr包。
3.consumeProguardFile(proguardFiles)：添加混淆文件进arr包。
4.externalNativeBuild(action)：配置本地的build选项。
5.initWith：复制这个build类型的所有属性。
6.proguardFile(proguardFile)：添加一个新的混淆配置文件。
7.proguradFiles(files):添加新的混淆文件
8.resValue(type,name,value)：添加一个新的生成资源
9.setProguardFiles(proguardFileIterable):设置一个混淆配置文件。

    }

    debug {

    }    
  }

  多渠道打包
  //所有打包配置（批量处理打包渠道--> manifestPlaceholders：设置打包渠道）
  productFlavors.all {
    //平台id
    flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
  }
  productFlavors {
    googlePlay {
    }

    xiaomi {
    }
ProductFlavors的属性：

1.applicationId：应用程序ID。
2.applicationIdSuffix：应用程序ID后缀。
3.consumerProguardFiles：混淆规则文件被包含在aar包中。
4.dimension：flavor名称的尺寸。
5.externalNativeBuild：详情见externalNativeBuild{}
6.flavorDeminsion：过时
7.generatedDensities：过时
8.jackOption：jack配置可选项。
9.javaCompileOptions：Java编译配置参数
10.manifestPlaceholders：manifest占位符
11.multiDexEnabled：是否进行dex拆分
12.multiDexKeepFile：文本文件编译进主dex文件中。
13.multiDexKeepProgroud：文本文件作为混淆规则编译进主dex文件中
14.ndk：ndk配置
15.proguardFiles:混淆文件
16.signingConfig：这个flavor的签名配置信息
17.testApplicationId：测试应用ID
18.testFunctionalTest：
19.testHandleProfiling：
20.testInstrumentationRunner：
21.testInstrumentionRunnerArguments：
22.useJack：过时
23.verctorDrawables：生成矢量图支持
24.versionCode：版本号
25.versionName:版本名
26.versionNameSuffix：版本名后缀
27.wearAppUnbundled：是否对嵌入式穿戴app进行拆分模式。如果true，那么这个app将在应用市场被分发为穿戴设备的app。

  }

  签名
  signingConfigs {
    config {
        keyAlias '...'
        keyPassword '...'
        storeFile file('C:/../Key.jks')
        storePassword '...'
    }

SigningConfig的属性：

1.keyAlias：签名使用key的别名
2.KeyPassword：签名使用的key的密码
3.storeFile：store签名文件
4.storePassword：store签名密码
5.storeType：store签名类型
6.v1SigningEnabled：是否使用jar签名(又名v1签名)。
7.v2SigningEnabled：是否使用apk签名(又名v2签名)。
  }


} 

AppExtension的属性
aaptOptions：aapt是一个可以将资源文件编译成二进制文件的工具。aaptOptions表示aapt工具设置的可选项参数。
adbExecutable：adb从编译sdk时执行
adbOptions：adb的可选项参数
applicationVariants：应用变体列表
==buildToolsVersion==：构建工具版本(必要的)
buildTypes：构建类型(一般是release和debug，还可以自定义)
compileOptions：编译可选项参数
==compileSdkVersion==：编译sdk版本(必要的)
dataBinding：Data Binding可选项参数(关于DataBinding的使用)
defualtConfig：默认配置，对于所有的打包项目
defualtPublishConfig：默认是release。使用参考
dexOptions：Dex可选项参数。
externalNativeBuild：native编译支持。参考
flavorDimensionList：
generatePureSplits：是否拆成多个APK
jacoco：JaCoCo可选项参数
lintOptions：Lint工具可选项参数
ndkDirectory：ndk目录(一般在local.properties中)
packagingOptions：packaging的可选参数
productFlavors：项目所有flavor
publishNonDefualt：不仅仅使用默认的publish artifacts。可参考defualtPublishConfig。
resourcePrefix：创建新资源时使用的前缀。
sdkDirectory：sdk目录(一般在local.properties中)
signingConfigs：签名文件的可选项参数
sourceSets：资源文件目录指定(Android中有自己的AndroidSourceSets，这个一般用于assets，jin等目录)
splits：splits类型。
testBuildType：测试构建类型
testOptions：测试可选项参数
testVariants：测试变体
unitTestVariants：单元测试变体
variantFilter：变体过滤器





任务从build.gradle，setting.gradle读取
对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。
buildscript{...}和allprojects{...}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性。
在项目根目录的build.gradle配置文件中，我们可以定制适用于所有模块的属性，通过ext 代码块来实现。如下所示：
ext {
  compileSdkVersion = 23
}
然后我们可以在模块目录的build.gradle配置文件中引用这些属性,引用语法为rootProject.ext.{属性名}
多个Module，可以将共有的minSdkVersion和targetSdkVersion抽取到Project中的build.gradle文件中
使用ext引用targetSdkVersion 不要写在android根目录，会报错


Android Studio中默认会使用 Gradle Wrapper 而不是直接使用Gradle。命令也是使用gradlew而不是gradle。


##### MediaPlayer

MediaPlayer其实是一个封装的很好的音频、视频流媒体操作类，如果查看其源码，会发现其内部是调用的native方法，所以它其实是有C++实现的。既然是一个流媒体操作类，那么必然涉及到，播放、暂停、停止等操作，实际上MediaPlayer也为我们提供了相应的方法来直接操作流媒体。

1、播放Raw下的元数据
//直接创建，不需要设置setDataSource
mMediaPlayer=MediaPlayer.create(this, R.raw.audio);
mMediaPlayer.start();
2、MediaPlayer设置播放源的4中方式
setDataSource (String path)

  //从sd卡中加载音乐
  mMediaPlayer.setDataSource("../music/samsara.mp3") ;
  //从网路加载音乐
  mMediaPlayer.setDataSource("http://..../xxx.mp3") ;
  //需使用异步缓冲
  mMediaPlayer.prepareAsync() ;
setDataSource (FileDescriptor fd)

  //需将资源文件放在assets文件夹
   AssetFileDescriptor fd = getAssets().openFd("samsara.mp3");
   mMediaPlayer.setDataSource(fd)
   mMediaPlayer.prepare() ;

   Ps:此方法系统需大于等于android 
setDataSource (Context context, Uri uri)

  一般通过ContentProvider获取Android系统提供的共享music获取uri，然后设置数据播放
setDataSource (FileDescriptor fd, long offset, long length)

  //需将资源文件放在assets文件夹
  AssetFileDescriptor fd = getAssets().openFd("samsara.mp3");
  mMediaPlayer.setDataSource(fd, fd.getStartOffset(), fd.getLegth())
  mMediaPlayer.prepare() ;
播放assets文件

3、注意点
设置完数据源，不要忘记prepare()，尽量使用异步prepareAync()，这样不会阻塞UI线程。

播放完毕即使释放资源,MediaPlayer是很消耗系统资源的，所以在使用完MediaPlayer，不要等待系统自动回收，最好是主动回收资源。

  mediaPlayer.stop(); 
  mediaPlayer.release(); 
  mediaPlayer = null; 
4、不足
资源占用量较高、延迟时间较长、不支持多个音频同时播放等
5、使用
1、创建MediaPlayer对象；  
2、设置数据源；
3、调用prepare，防止卡界面用异步方式prepareAsyc（）；
4、设置onPrepare监听，异步加载完之后条用start()播放
5、切换数据源先调用reset然后调用setDataSource
6、释放资源


/**
 * desc: 播放
 */
private void play(File file) {
    if (player == null) {
        player = new MediaPlayer();
    }

    if (player.isPlaying()) {
        player.stop();
    }
    player.reset();
    try {
        player.setDataSource(file.getAbsolutePath());
        player.prepareAsync();
        player.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
            @Override
            public void onPrepared(MediaPlayer mp) {
                player.start();
            }
        });
    } catch (IOException e) {
        e.printStackTrace();
    }
}

7、进度控制
通过使用mediaplayer.getcurrent();获得当前的播放时间进度，单位为100毫秒
通过使用mediaplayer.getDuration();获得播放总持续时间，这是进度，然后启动一个子线程回调进程即可

    //设置进度条最大进度
  ((Fragment2) getParentFragment()).getPlayProgress().setMax(player.getDuration());
        new Thread(new Runnable() {
                 @Override
                 public void run() {
                        while (!isPlayComplete) {
                            if (player.isPlaying()) {
                                    //设置进度
                                    ((Fragment2) getParentFragment()).getPlayProgress().setProgress(player.getCurrentPosition());
                                    try {
                                        Thread.sleep(100);//睡眠100毫秒
                                    } catch (Exception e) {
                                        e.printStackTrace();
                                    }
                                }
                            }
                        }
                    }
                }).start();
6、API
void statr()：开始或恢复播放。
void stop()：停止播放。
void pause()：暂停播放。　　
　　通过上面三个方法，只要设定好流媒体数据源，即可在应用中播放流媒体资源，为了更好的操作流媒体，MediaPlayer还为我们提供了一些其他的方法，这里列出一些常用的，详细内容参阅官方文档。

int getDuration()：获取流媒体的总播放时长，单位是毫秒。
int getCurrentPosition()：获取当前流媒体的播放的位置，单位是毫秒。
void seekTo(int msec)：设置当前MediaPlayer的播放位置，单位是毫秒。
void setLooping(boolean looping)：设置是否循环播放。
boolean isLooping()：判断是否循环播放。
boolean  isPlaying()：判断是否正在播放。
void prepare()：同步的方式装载流媒体文件。
void prepareAsync()：异步的方式装载流媒体文件。
void release ()：回收流媒体资源。 
void setAudioStreamType(int streamtype)：设置播放流媒体类型。
void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。
setNextMediaPlayer(MediaPlayer next)：设置当前流媒体播放完毕，下一个播放的MediaPlayer。

大部分方法的看方法名就可以理解，但是有几个方法需要单独说明一下。
在使用MediaPlayer播放一段流媒体的时候，需要使用prepare()或prepareAsync()方法把流媒体装载进MediaPlayer，才可以调用start()方法播放流媒体。　　　　　　　　　　　　　　　　　
setAudioStreamType()方法用于指定播放流媒体的类型，它传递的是一个int类型的数据，均以常量定义在AudioManager类中， 一般我们播放音频文件，设置为AudioManager.STREAM_MUSIC即可。
除了上面介绍的一些方法外，MediaPlayer还提供了一些事件的回调函数，这里介绍几个常用的：

setOnCompletionListener(MediaPlayer.OnCompletionListener listener)：当流媒体播放完毕的时候回调。
setOnErrorListener(MediaPlayer.OnErrorListener listener)：当播放中发生错误的时候回调。
setOnPreparedListener(MediaPlayer.OnPreparedListener listener)：当装载流媒体完毕的时候回调。
setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)：当使用seekTo()设置播放位置的时候回调。

https://github.com/AaronYang23/BlogFiles/blob/ec1692e348c2280eeb9e2d0ac74c03eaa6328869/hexo/source/_posts/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE.md

> 有时希望声音能够从Speakerphone(扬声器)发出，有时候希望声音能够从earpiece(听筒)发出
//扬声器
//MediaPlayer
MediaPlayer mMediaPlayer = new MediaPlayer();
AudioManager mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
//这里的三个参数建议封装一下，便于适配（哪些机型需要适配就不说了）
mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);//有些机器需要使用AudioManager.STREAM_VOICE_CALL
mAudioManager.setMode(AudioManager.MODE_NORMAL);
mAudioManager.setSpeakerphoneOn(true);
... mMediaPlayer.setDataSource、prepare、start等等

//听筒
MediaPlayer mMediaPlayer = new MediaPlayer();
AudioManager mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
//这里的三个参数建议封装一下，便于适配（哪些机型需要适配就不说了），这里需要适配的机型很多，但是大部分有问题的机型使用通用mode就行（AudioManager.MODE_NORMAL）,少数一两个特殊的机型，特殊处理
if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_VOICE_CALL);
    mAudioManager.setMode(AudioManager.MODE_IN_CALL);
} else {
    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_VOICE_CALL);
    mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);
}
mAudioManager.setSpeakerphoneOn(false);
... mMediaPlayer.setDataSource、prepare、start等等

##### BroadcastReceiver
```bash
// 广播使用了设计模式中的观察者模式：基于消息的发布 / 订阅事件模型
消息订阅者（广播接收者）通过binder机制在AMS中注册 =>通过消息循环拿到接受的广播，并调用onReceive()
消息发布者（广播发布者）通过Binder机制向AMS发送广播
消息中心（AMS，即Activity Manager Service）Ams根据广播发送者要求，在已注册列表中，寻找合适的广播接收者

// 广播接收者
// 继承BroadcastReceivre基类
public class mBroadcastReceiver extends BroadcastReceiver {

  // 复写onReceive()方法
  // 接收到广播后，则自动调用该方法
  @Override
  public void onReceive(Context context, Intent intent) {
   //写入接收广播后的操作
    }
}

广播接收器注册的方式分为两种：静态注册、动态注册
// 静态注册
// 常驻广播
<receiver 
    android:enabled=["true" | "false"]
    //此broadcastReceiver能否接收其他App的发出的广播
    //默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false
    android:exported=["true" | "false"]
    android:icon="drawable resource"
    android:label="string resource"
    //继承BroadcastReceiver子类的类名
    android:name=".mBroadcastReceiver"
    //具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；
    android:permission="string"
    //BroadcastReceiver运行所处的进程
    //默认为app的进程，可以指定独立的进程
    //注：Android四大基本组件都可以通过此属性指定自己的独立进程
    android:process="string" >

    //用于指定此广播接收器将接收的广播类型
    //本示例中给出的是用于接收网络状态改变时发出的广播
    <intent-filter>
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
    </intent-filter>
</receiver>

// 动态注册
// 动态广播最好在Activity 的 onResume()注册、onPause()注销。onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。
// 对于动态广播，有注册就必然得有注销，否则会导致内存泄露
// 非常住广播
public Activity xxx {
    // 选择在Activity生命周期方法中的onResume()中注册
    @Override
    protected void onResume(){
        super.onResume();

        // 1. 实例化BroadcastReceiver子类 &  IntentFilter
        mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver();
        IntentFilter intentFilter = new IntentFilter();

        // 2. 设置接收广播的类型
        intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);

        // 3. 动态注册：调用Context的registerReceiver（）方法
        this.registerReceiver(mBroadcastReceiver, intentFilter);
    }


    // 注册广播后，要在相应位置记得销毁广播
    // 即在onPause() 中unregisterReceiver(mBroadcastReceiver)
    // 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中
    // 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。
    @Override
    protected void onPause() {
        super.onPause();
        //销毁在onResume()方法中的广播
        this.unregisterReceiver(mBroadcastReceiver);
    }

}

Activity生命周期的方法是成对出现的：

onCreate() & onDestory()
onStart() & onStop()
onResume() & onPause()

// 不在onCreate() & onDestory() 或 onStart() & onStop()注册、注销是因为：
// 当系统因为内存不足（优先级更高的应用需要内存，请看上图红框）要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。
// 假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。
// 但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。

系统广播
系统操作                                        action
监听网络变化                                  android.net.conn.CONNECTIVITY_CHANGE
关闭或打开飞行模式                             Intent.ACTION_AIRPLANE_MODE_CHANGED
充电时或电量发生变化                           Intent.ACTION_BATTERY_CHANGED
电池电量低                                    Intent.ACTION_BATTERY_LOW
电池电量充足（即从电量低变化到饱满时会发出广播     Intent.ACTION_BATTERY_OKAY
系统启动完成后(仅广播一次)                      Intent.ACTION_BOOT_COMPLETED
按下照相时的拍照按键(硬件按键)时                 Intent.ACTION_CAMERA_BUTTON
屏幕锁屏                                      Intent.ACTION_CLOSE_SYSTEM_DIALOGS
设备当前设置被改变时(界面语言、设备方向等)         Intent.ACTION_CONFIGURATION_CHANGED
插入耳机时                                    Intent.ACTION_HEADSET_PLUG
未正确移除SD卡但已取出来时(正确移除方法:设置--SD卡和设备内存--卸载SD卡)  Intent.ACTION_MEDIA_BAD_REMOVAL
插入外部储存装置（如SD卡）                      Intent.ACTION_MEDIA_CHECKING
成功安装APK                                 Intent.ACTION_PACKAGE_ADDED
成功删除APK                                 Intent.ACTION_PACKAGE_REMOVED
重启设备                                    Intent.ACTION_REBOOT
屏幕被关闭                                   Intent.ACTION_SCREEN_OFF
屏幕被打开                                   Intent.ACTION_SCREEN_ON
关闭系统时                                   Intent.ACTION_SHUTDOWN
重启设备                                    Intent.ACTION_REBOOT

```

##### Service
根据进程位置分类：
本地服务：
本地服务依附在主进程上而不是独立的进程这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC也不需要AIDL。相应bindService会方便很多。主进程被Kill后服务便会终止。
远程服务： 指定android:process
远程服务为独立的由于是独立的进程因此在Activity所在进程被Kill的时候该服务依然在运行不受其他进程影响有利于为多个进程提供服务具有较高的灵活性该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。

service 和 thread 
当 Activity 被finish之后你不再持有该 Thread的引用
你没有办法在不同的Activity 中对同一 Thread进行控制



android:exported：代表是否能被其他应用隐式调用
其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intentfilter匹配也无法打开即无法被其他应用隐式调用。
android:permission：是权限声明
android:process：是否需要在单独的进程中运行
代表Service在单独的进程中运行。“remote”和”:remote”不是同一个意思前者的进程名称为：remote而后者的进程名称为：App-packageName:remote。
android:isolatedProcess ：特殊的进程下运行
个进程与系统其他进程分开且没有自己的权限与其通信的唯一途径是通过服务的API(bind and start)。
android:enabled：是否可以被系统实例化 true


onStartCommand()方法的返回值:

START_NOT_STICKY 不会立即重新启动
表示当Service运行的进程被Android系统强制杀掉之后，不会重新创建该Service。
当然如果在其被杀掉之后一段时间又调用了startService，那么该Service又将被实例化。

某个Service需要定时从服务器获取最新数据：
通过一个定时器每隔指定的N分钟让定时器启动Service去获取服务端的最新数据。
当执行到Service的onStartCommand时，
在该方法内再规划一个N分钟后的定时器用于再次启动该Service并开辟一个新的线程去执行网络操作。
假设Service在从服务器获取最新数据的过程中被Android系统强制杀掉，Service不会再重新创建，因为再过N分钟定时器就会再次启动该Service并重新获取数据。

START_STICKY 会立即重新启动不保存数据
表示Service运行的进程被Android系统强制杀掉之后，Android系统会将该Service依然设置为started状态（即运行状态），
但是不再保存onStartCommand方法传入的intent对象，然后Android系统会尝试再次重新创建该Service，并执行onStartCommand回调方法，
但是onStartCommand回调方法的Intent参数为null，也就是onStartCommand方法虽然会执行但是获取不到intent信息。

Service可以在任意时刻运行或结束都没什么问题，而且不需要intent信息：
比如一个用来播放背景音乐功能的Service就适合返回该值。

START_REDELIVER_INTENT 立即重启保存数据
表示Service运行的进程被Android系统强制杀掉之后，Android系统会将再次重新创建该Service，并执行onStartCommand回调方法，
但是不同的是Android系统会再次将Service在被杀掉之前最后一次传入onStartCommand方法中的Intent再次保留下来并再次传入到重新创建后的Service的onStartCommand方法中，这样我们就能读取到intent参数。

启动方式：
method1:




##### WorkManager
WorkManager 旨在用于可延迟运行（即不需要立即运行）并且在应用退出或设备重启时必须能够可靠运行的任务。例如：

向后端服务发送日志或分析数据
定期将应用数据与服务器同步

操作：
将 WorkManager 添加到您的 Android 项目中
创建后台任务
配置运行任务的方式和时间
将任务提交给系统

##### Toast
mHandler 处理显示，隐藏，取消命令
handleShow 时，队列中有CANCEL或者HIDE命令都将会使显示操作提前终止，永远不会显示

##### Handler
android在ActivityThread的main(）方法里直接初始化好了Looper
```bash
Looper.prepareMainLooper();
ActivityThread thread = new ActivityThread();
thread.attach(false);
Looper.loop();
```

在其他线程中，想要使用Handler，要手动去执行Looper的prepare()和loop().

prepare == prepare(true) 允许quit
loop() 在当前线程取出消息队列，交给handler分发 完成后要调用quit()结束loop

子线程中使用
直接调用Looper.prepare()方法即可为当前线程创建Looper对象
而它的构造器会创建配套的MessageQueue;
创建Handler对象,重写handleMessage( )方法就可以处理来自于其他线程的信息了! 
调用Looper.loop()方法启动Looper

要刷新UI，handler要用到主线程的looper。
那么在主线程 Handler handler = new Handler();
如果在其他线程，也要满足这个功能的话，要Handler handler = new Handler(Looper.getMainLooper());

##### 应用架构指南
https://developer.android.google.cn/jetpack/docs/guide

常见的架构原则
  分离关注点
    不要在Activity 或 Fragment 中编写所有代码。使这些类保持精简
  通过模型驱动界面
    模型是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。

推荐应用架构    
  使用Android 架构组件
  https://developer.android.google.cn/topic/libraries/architecture
    使用 生命周期感知型组件处理生命周期 帮助您管理 Activity 和 Fragment 的生命周期
    https://developer.android.google.cn/topic/libraries/architecture/lifecycle
    使用 LiveData 构建数据对象，在基础数据库改变时通知视图。
    https://developer.android.google.cn/topic/libraries/architecture/livedata
    ViewModel 存储界面相关的数据，这些数据不会在应用轮转时销毁。
    https://developer.android.google.cn/topic/libraries/architecture/viewmodel
    Room 是一个 SQLite 对象映射库。它可用来避免样板代码，并轻松地将 SQLite 表数据转换为 Java 对象。
    Room 提供 SQLite 语句的编译时检查，并且可以返回 RxJava、Flowable 和 LiveData 可观察对象。
    https://developer.android.google.cn/topic/libraries/architecture/room

##### NDK
ndk目录 ～/Library/Android/sdk/ndk
使用ndk的路径不能有空格

Android.mk是一个makefile配置文件，安卓大量采用makefile进行自动化编译。LOCAL_MODULE定义的名称就是编译好的so库名称，比如这里是jni-demo，最终生成的动态库名称就叫libjni-demo.so。 LOCAL_SRC_FILES表示参与编译的源文件名称，这里就是demo.c

JNI
  https://developer.android.google.cn/training/articles/perf-jni?hl=zh_cn
  JNI 是指 Java 原生接口。它定义了 Android 从受管理代码（使用 Java 或 Kotlin 编程语言编写）编译的字节码与原生代码（使用 C/C++ 编写）互动的方式。
  JNI 不依赖于供应商，支持从动态共享库加载代码，虽然较为繁琐，但有时相当有效。
  要浏览全局 JNI 引用并查看这些引用创建和删除的位置，请使用 Android Studio 3.2 及更高版本的内存分析器中的 JNI 堆视图。
  尽量减少 JNI 层的占用空间
    1.尽可能减少跨 JNI 层编组资源的次数。 
    跨 JNI 层进行编组的费用十分高昂。尝试设计一种接口，尽可能减少需要编组的数据量以及必须进行数据编组的频率。
    2.尽可能避免在使用受管理编程语言编写的代码与使用 C++ 编写的代码之间进行异步通信。
    这样可使 JNI 接口更易于维护。通常，您可以使用与界面相同的语言保持异步更新，以简化异步界面更新。
    例如，最好使用 Java 编程语言在两个线程之间进行回调（其中一个线程发出阻塞 C++ 调用，然后在阻塞调用完成时通知界面线程），
    而不是通过 JNI 从界面线程调用使用 Java 代码的 C++ 函数。
    3.尽可能减少需要接触 JNI 或被 JNI 接触的线程数。
    如果您确实需要以 Java 和 C++ 这两种语言来利用线程池，请尝试在池所有者之间（而不是各个工作线程之间）保持 JNI 通信。
    4.将接口代码保存在少量易于识别的 C++ 和 Java 源位置，以便将来进行重构。 考虑在适当时使用 JNI 自动生成库。
  JavaVM 和 JNIEnv
    JNI 定义了两个关键数据结构，即“JavaVM”和“JNIEnv”。两者本质上都是指向函数表的二级指针。
    （在 C++ 版本中，它们是一些类，这些类具有指向函数表的指针，并具有每个通过该函数表间接调用的 JNI 函数的成员函数。）
    JavaVM 提供“调用接口”函数，您可以利用此类来函数创建和销毁 JavaVM。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。 
    JNIEnv 提供了大部分 JNI 函数。您的原生函数都会收到 JNIEnv 作为第一个参数。
    该 JNIEnv 将用于线程本地存储。因此，您无法在线程之间共享 JNIEnv。
    如果一段代码无法通过其他方法获取自己的 JNIEnv，您应该共享相应 JavaVM，然后使用 GetEnv 发现线程的 JNIEnv。 
    JNIEnv 和 JavaVM 的 C 声明与 C++ 声明不同。
    "jni.h" 包含文件会提供不同的类型定义符，具体取决于该文件是包含在 C 还是 C++ 中。
    因此，我们不建议在这两种语言包含的标头文件中添加 JNIEnv 参数。
  线程
    所有线程都是 Linux 线程，由内核调度。线程通常从受管理代码启动（使用 Thread.start），但也可以在其他位置创建，然后附加到 JavaVM。
    例如，使用 pthread_create 启动的线程可以附加 JNI AttachCurrentThread 或 AttachCurrentThreadAsDaemon 函数。
    在附加之前，线程不包含任何 JNIEnv，也无法调用 JNI。
    附加原生创建的线程会构建 java.lang.Thread 对象并将其添加到“主”ThreadGroup，从而使调试程序能够看到它。
    在已附加的线程上调用 AttachCurrentThread 属于空操作。
    Android 不会挂起执行原生代码的线程。如果正在进行垃圾回收，或者调试程序已发出挂起请求，则在线程下次调用 JNI 时，Android 会将其挂起。
    通过 JNI 附加的线程在退出之前必须调用 DetachCurrentThread。如果直接对此进行编码会很棘手，
    在 Android 2.0 (Eclair) 及更高版本中，您可以使用 pthread_key_create 定义将在线程退出之前调用的析构函数，
    之后再调用 DetachCurrentThread。  
  jclass、jmethodID 和 jfieldID
    如果要通过原生代码访问对象的字段，请执行以下操作：
      使用 FindClass 获取类的类对象引用
      使用 GetFieldID 获取字段的字段 ID
      使用适当内容获取字段的内容，例如 GetIntField
    同样，要调用方法，首先要获取类对象引用，然后获取方法 ID。
    方法 ID 通常只是指向内部运行时数据结构的指针。
    查找方法 ID 可能需要进行多次字符串比较，但一旦获取此类 ID，便可以非常快速地进行实际调用以获取字段或调用方法。
    如果性能很重要，我们建议您查找一次这些值并将结果缓存在原生代码中。
    由于每个进程只能包含一个 JavaVM，因此将这些数据存储在静态本地结构中是一种合理的做法。
    在取消加载类之前，类引用、字段 ID 和方法 ID 保证有效。
    只有在与 ClassLoader 关联的所有类可以进行垃圾回收时，系统才会取消加载类，这种情况很少见，但在 Android 中并非不可能。
    但请注意，jclass 是类引用，必须通过调用 NewGlobalRef 来保护它  
    如果您想在加载类时缓存方法 ID，并在取消加载类后重新加载时自动重新缓存方法 ID，那么初始化方法 ID 的正确做法是将以下代码添加到相应类中
      private static native void nativeInit();
      static {
          nativeInit();
      }
    在执行 ID 查找的 C/C++ 代码中创建 nativeClassInit 方法。初始化类时，该代码会执行一次。
    如果要取消加载类之后再重新加载，该代码将再次执行。  
  局部引用和全局引用
    传递给原生方法的每个参数，以及 JNI 函数返回的几乎每个对象都属于“局部引用”。
    这意味着，局部引用在当前线程中的当前原生方法运行期间有效。 在原生方法返回后，即使对象本身继续存在，该引用也无效。
    这适用于 jobject 的所有子类，包括 jclass、jstring 和 jarray。
    （启用扩展的 JNI 检查时，运行时会针对大部分引用误用问题向您发出警告。）
    获取非局部引用的唯一方法是通过 NewGlobalRef 和 NewWeakGlobalRef 函数。
    如果您希望长时间保留某个引用，则必须使用“全局”引用。
    NewGlobalRef 函数将局部引用作为参数，然后返回全局引用。
    在调用 DeleteGlobalRef 之前，全局引用保证有效。
    这种模式通常在缓存 FindClass 返回的 jclass 时使用，例如：
      jclass localClass = env->FindClass("MyClass");
      jclass globalClass = reinterpret_cast<jclass>(env->NewGlobalRef(localClass));
    所有 JNI 方法都接受局部和全局引用作为参数。对同一对象的引用可能具有不同的值。
    例如，对同一对象连续调用 NewGlobalRef 所返回的值可能有所不同。 
    要了解两个引用是否引用同一对象，必须使用 IsSameObject 函数。 
    切勿在原生代码中使用 == 比较各个引用。
    如果使用此符号，您就不能假设对象引用在原生代码中是常量或唯一值。
    在两次调用同一个方法时，表示某个对象的 32 位值可能有所不同；而在连续调用方法时，两个不同的对象可能具有相同的 32 位值。
    请勿将 jobject 值用作键。
    程序员需要“不过度分配”局部引用。
    实际上，这意味着如果您要创建大量局部引用（也许是在运行对象数组时），应该使用 DeleteLocalRef 手动释放它们，而不是让 JNI 为您代劳。
    该实现仅需要为 16 个局部引用保留槽位，因此如果您需要更多槽位，则应该按需删除，或使用 EnsureLocalCapacity/PushLocalFrame 保留更多槽位。
    请注意，jfieldID 和 jmethodID 属于不透明类型，不是对象引用，且不应传递给 NewGlobalRef。函数返回的 GetStringUTFChars 和 GetByteArrayElements 等原始数据指针也不属于对象。
    （这些指针可以在线程之间传递，并且在匹配的 Release 调用完成之前一直有效。）
    还有一种不寻常的情况值得单独提及。
    如果使用 AttachCurrentThread 附加原生线程，那么在线程分离之前，您运行的代码将绝不会自动释放局部引用。
    您创建的任何局部引用都必须手动删除。通常，在循环中创建局部引用的任何原生代码可能需要执行某些手动删除操作。
    请谨慎使用全局引用。全局引用不可避免，但它们很难调试，并且可能会导致难以诊断的内存（不良）行为。
    在所有其他条件相同的情况下，全局引用越少，解决方案的效果可能越好。  
  UTF-8 和 UTF-16 字符串
    Java 编程语言使用的是 UTF-16。
    为方便起见，JNI 还提供了使用修改后的 UTF-8 的方法。
    修改后的编码对 C 代码非常有用，因为它将 \u0000 编码为 0xc0 0x80，而不是 0x00。
    这样做的好处是，您可以依靠以零终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。
    但缺点是，您无法将任意 UTF-8 数据传递给 JNI 并期望它能够正常工作。
    如果可能，使用 UTF-16 字符串执行操作通常会更快。
    Android 目前不需要 GetStringChars 的副本，而 GetStringUTFChars 需要分配和转换为 UTF-8。
    请注意，UTF-16 字符串不是以零终止的，并且允许使用 \u0000，因此您需要保留字符串长度和 jchar 指针。
    不要忘记 Release 您 Get 的字符串。字符串函数会返回 jchar* 或 jbyte*，它们是指向原始数据而非局部引用的 C 样式指针。
    这些指针在调用 Release 之前保证有效，这意味着在原生方法返回时不会释放这些指针。
    传递给 NewStringUTF 的数据必须采用修改后的 UTF-8 格式。
    一种常见的错误就是从文件或网络数据流中读取字符数据，并在未过滤的情况下将其传递给 NewStringUTF。
    除非您确定数据是有效的 MUTF-8（或 7 位 ASCII，这是一个兼容子集），否则您需要剔除无效字符或将它们转换为适当的修改后的 UTF-8 格式。
    如果不这样做，UTF-16 转换可能会产生意外的结果。CheckJNI 默认状态下为模拟器启用，它会扫描字符串并且在收到无效输入时会中止虚拟机。 
  原始数组
    JNI 提供访问数组对象内容的函数。
    虽然访问对象数组时只能一次访问一个条目，但可以直接读写原始类型的数组，就像它们是在 C 语言中声明的一样。
    为了在不限制虚拟机实现的情况下使接口尽可能高效，Get<PrimitiveType>ArrayElements 系列调用允许运行时返回指向实际元素的指针，或者分配一些内存并进行复制。
    无论采用哪种方式，在发出相应的 Release 调用之前，返回的原始指针保证有效（这意味着，如果没有复制数据，数组对象的位置将固定不变，并且无法在压缩堆期间重新调整位置）。
    您必须 Release 自己 Get 到的每个数组。 此外，如果 Get 调用失败，您必须确保自己的代码稍后不会试图Release NULL 指针。
    您可以通过传入 isCopy 参数的非 NULL 指针来确定是否复制了数据。但这用处不大。
    Release 调用采用的 mode 参数可以具有三个值中的一个。运行时执行的操作取决于其返回的指针是指向实际数据还是指向数据副本： 
      0
        实际数据：数组对象未固定。
        数据副本：已复制回数据。释放了包含相应副本的缓冲区。
      JNI_COMMIT
        实际数据：不执行任何操作。
        数据副本：已复制回数据。未释放包含相应副本的缓冲区。
      JNI_ABORT
        实际数据：数组对象未固定。未中止早期的写入数据。
        数据副本：释放了包含相应副本的缓冲区；对该副本所做的任何更改都会丢失。
    检查 isCopy 标志的其中一个原因是，了解您是否需要在对数组进行更改后使用 JNI_COMMIT 调用 Release - 
    如果您要在进行更改和执行使用数组内容的代码之间切换，则可以跳过空操作提交。
    检查该标志的另一个可能的原因是为了有效处理 JNI_ABORT。
    例如，您可能想要获取一个数组、对其进行适当修改、将片段传递给其他函数，然后舍弃所做的更改。
    如果您知道 JNI 要为您创建新副本，则无需创建另一个“可修改”副本。如果 JNI 要将原始数据传递给您，那么您需要制作自己的副本。
    主观认为在 *isCopy 为 false 时您可以跳过 Release 调用是一种常见误区（在示例代码中重复出现过这种情况）。
    事实并非如此。如果没有分配任何副本缓冲区，则必须固定原始内存，并且不能由垃圾回收器移动。
    另请注意，JNI_COMMIT 标记不会释放数组，您最终需要使用其他标记再次调用 Release。    
  区域调用
    https://developer.android.google.cn/training/articles/perf-jni?hl=zh_cn#%E5%8C%BA%E5%9F%9F%E8%B0%83%E7%94%A8


向您的项目添加 C 和 C++ 代码
  Android 项目添加 C 和 C++ 代码，只需将相应的代码添加到项目模块的 cpp 目录中即可。
  在您构建项目时，这些代码会编译到一个可由 Gradle 与您的 APK 打包在一起的原生库中。
  然后，Java 或 Kotlin 代码即可通过 Java 原生接口 (JNI) 调用原生库中的函数。
  Android Studio 支持适用于跨平台项目的 CMake，以及速度比 CMake 更快但仅支持 Android 的 ndk-build。
  目前不支持在同一模块中同时使用 CMake 和 ndk-build。

##### 通过 lint 检查改进代码
结构不合理的代码会影响 Android 应用的可靠性和效率，并使您的代码更难以维护，而 lint 工具有助于找到这些代码。
例如，如果 XML 资源文件包含未使用的命名空间，这样不仅占用空间，而且还会导致不必要的处理。
其他结构问题（如使用目标 API 版本不支持的已弃用的元素或 API 调用）可能会导致代码无法正常运行。
lint 帮助您发现并更正代码结构质量的问题，而无需您实际执行应用，也不必编写测试用例。
系统会报告该工具检测到的每个问题并提供问题的描述消息和严重级别，以便您可以快速确定需要优先进行的关键改进。
此外，您还可以降低问题的严重级别以忽略与项目无关的问题，或者提高严重级别以突出特定问题。
lint 工具可以检查您的 Android 项目源文件是否有潜在的错误，以及在正确性、安全性、性能、易用性、无障碍性和国际化方面是否需要优化改进。
使用 Android Studio 时，无论何时构建应用，都会运行配置的 lint 和 IDE 检查。
不过，您可以手动运行检查或从命令行运行 lint。

应用源文件( Java、Kotlin 和 XML 文件、图标以及 ProGuard 配置文件) + lint.xml 文件(一个配置文件，可用于指定要排除的任何 lint 检查以及自定义问题严重级别。)
||
\/
lint 工具(一个静态代码扫描工具，您可以从命令行或在 Android Studio 中对 Android 项目运行该工具。Lint 工具检查可能会影响 Android 应用的质量和性能的代码结构问题。强烈建议您先更正 Lint 检测到的所有错误，然后再发布您的应用。)
||
\/
lint 检查结果(可以在控制台或 Android Studio 的 Inspection Results 窗口中查看 lint 检查结果)

从命令行运行 lint
  gradlew lint | ./gradlew lint
  Lint 工具完成其检查后，会提供 XML 和 HTML 版 Lint 报告的路径。
  如果您的项目包含一些版本变体，而您希望仅对某个特定的版本变体运行 lint 任务，则必须将该变体名称的首字母大写，并在其前面加上 lint 作为前缀。
  gradlew lintDebug
使用独立工具运行 lint android_sdk/tools/
  lint [flags] <project directory  扫描 myproject 目录及其子目录下的文件。问题 ID MissingPrefix 提示 lint 仅扫描缺少 Android 命名空间前缀的 XML 属性。
    lint --check MissingPrefix myproject 
  命令行参数的完整列表  
    lint --help  
将 lint 配置为抑制警告
  默认情况下，当您运行 lint 扫描时，lint 工具会检查它支持的所有问题。
  在 Android Studio 中配置 Lint
    1.作为代码编辑器中的弹出文本查看。lint 发现问题后，会用黄色突出显示有问题的代码，而对于更严重的问题，则会在代码下面添加红色下划线。
    2.依次点击 Analyze > Inspect Code 后，在 lint Inspection Results 窗口中查看
  配置 lint 文件  Android 项目的根目录下
    lint.xml 文件由封闭的 <lint> 父标记组成，此标记包含一个或多个 <issue> 子元素。lint 会为每个 <issue> 定义唯一的 id 属性值。
    提示：如需查看 lint 支持的问题及其对应的问题 ID 的完整列表，请运行 lint --list 命令。
  配置 Java、Kotlin 和 XML 源文件的 lint 检查
    提示：您可以在 Default Preferences 对话框中管理 lint 检查 Java、Kotlin 或 XML 源文件的功能。 只需依次选择 File > Other Settings > Default Settings，然后在 Default Preferences 对话框的左侧窗格中依次选择 Editor > Inspections。
    配置 Java 或 Kotlin 的 lint 检查
      要专门对 Android 项目中的某个类或方法停用 lint 检查，请向该代码添加 @SuppressLint 注释
      要禁止 lint 检查文件中的所有问题，请使用 all 关键字，如下所示：
        @SuppressLint("all")  
    配置 XML 的 lint 检查
      以使用 tools:ignore 属性对 XML 文件的特定部分停用 lint 检查。在 lint.xml 文件中添加以下命名空间值，以便 lint 工具能够识别该属性。
        namespace xmlns:tools="http://schemas.android.com/tools"
      对 XML 布局文件的 <LinearLayout> 元素中的 UnusedResources 问题关闭 lint 检查
        <LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        tools:ignore="UnusedResources" >
      如果某个父元素声明了 ignore 属性，则该元素的子元素会继承此属性。在本例中，也会对 <TextView> 子元素停用 lint 检查。
      要禁止检查多个问题，请使用以逗号分隔的字符串列出要禁止检查的问题。
        tools:ignore="NewApi,StringFormatInvalid"
      要禁止 lint 检查 XML 元素中的所有问题，请使用 all 关键字，如下所示：
        tools:ignore="all"
通过 Gradle 配置 lint 选项
  build.gradle 文件中的 lintOptions {} 代码块配置某些 lint 选项，例如要运行或忽略哪些检查
      lintOptions {
        // Turns off checks for the issue IDs you specify.
        disable 'TypographyFractions','TypographyQuotes'
        // Turns on checks for the issue IDs you specify. These checks are in
        // addition to the default lint checks.
        enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
        // To enable checks for only a subset of issue IDs and ignore all others,
        // list the issue IDs with the 'check' property instead. This property overrides
        // any issue IDs you enable or disable using the properties above.
        check 'NewApi', 'InlinedApi'
        // If set to true, turns off analysis progress reporting by lint.
        quiet true
        // if set to true (default), stops the build if errors are found.
        abortOnError false
        // if true, only report errors.
        ignoreWarnings true
      }              
创建警告基准
  为项目的当前警告集创建快照，然后将该快照用作将来运行检查的基准，以便只报告新问题。 
  有了基准快照，您便可开始使用 lint 让构建失败，而不必先返回并解决所有现有问题。  
      lintOptions {
        baseline file("lint-baseline.xml")
      }
  添加此代码行时，系统会创建 lint-baseline.xml 文件以建立基准。此后，lint 工具仅读取该文件以确定基准。
  如果要创建新基准，请手动删除该文件并再次运行 lint 以重新创建它。
  从 IDE（依次选择 Analyze > Inspect Code）或从命令行运行 lint，如下所示。系统会输出 lint-baseline.xml 文件的位置。
  自定义基准
    如果要将某些问题类型（而不是全部）添加到基准，您可以通过修改项目的 build.gradle 文件来指定要添加的问题
      lintOptions {
        check 'NewApi', 'HandlerLeak'
        baseline file("lint-baseline.xml")
      }
  基准警告 
    实行基准时，您会收到一条信息性警告，告知您一个或多个问题已被过滤掉，因为它们已在基准中列出。
    之所以发出这条警告，是为了帮您记住您已配置基准，因为理想情况下，您希望在某一时刻解决所有问题。
    这条信息性警告不仅会告知您过滤掉的错误和警告的确切数量，而且还会跟踪不再报告的问题。
    此信息可让您知道是否确实解决了问题，以便您可以选择性地重新创建基准，以防止错误再次出现时检测不到。
手动运行检查
  选择 Analyze > Inspect Code，手动运行配置的 lint 及其他 IDE 检查。检查结果将显示在 Inspection Results 窗口中。
  https://developer.android.google.cn/studio/write/lint?hl=zh_cn#manuallyRunInspections


##### 数十亿用户的连接
处理混合连接
  适当地存储数据、安排请求队列和处理图像，以应对离线和慢速连接的情况。
  1.优化图像
    提供 WebP 图像  WebP 文件，以缩短图像加载时间，并节省网络带宽 VP8 VP9
    动态调整图像尺寸 根据网络类型或网络质量发出图像尺寸请求
    使用图像加载库  Glide  Picasso 由于图像已缓存，这些库会在下一次收到图像请求时返回本地副本。
  2.优化网络连接
    让您的应用可离线使用 
      将数据存储在本地、缓存数据，以及建立出站请求队列以待连接恢复时完成相关操作。 
      只有在用户执行的操作必须连接网络时才需要通知用户。
      即便在设备处于离线状态时，用户也可以通过电子邮件客户端撰写、发送、阅读、移动和删除现有邮件。
      这些操作可缓存起来，在连接恢复时执行。这样一来，无论设备在线还是离线，应用均可提供相似的用户体验。
    使用 GcmNetworkManager 
      和内容提供程序 GCM 网络管理器 (GcmNetworkManager) 可提供稳健的机制与服务器同步数据，
      而内容提供程序 (ContentProvider) 可缓存这些数据，两者结合使用所形成的架构可实现实用的离线状态。
      在发出后续请求之前，应用应显示本地缓存的数据。
      这可以确保应用在设备离线或网络连接速度缓慢、不可靠的情况下正常工作。
      https://developers.google.cn/android/reference/com/google/android/gms/gcm/GcmNetworkManager 
    网络请求去重 
      离线优先架构最初会尝试从本地存储获取数据，失败时才会从网络请求数据。
      从网络检索数据后，数据将缓存在本地以供日后检索。
      这有助于确保同一组数据只通过网络请求一次，后续请求可通过本地数据得到满足。
      使用本地数据库来存储长期存在的数据（通常是 android.database.sqlite 或 SharedPreferences）。
      使用 DiskLruCache 等有界磁盘缓存。通常不会发生变化的数据只应通过网络请求一次，然后缓存起来以供日后使用。
      举例来说，图像以及新闻文章或社交帖子之类的非时间性文档便属于此类数据。
  3.微调数据传送
    划分带宽优先级 
      您不应假定设备连接的任何网络均能保持持久或可靠的连接。
      最有用的信息尽快显示给用户。
      立即为用户提供可见的相关信息可带来更好的用户体验。
      这可以缩短用户的等待时间，并提高应用在连接慢速网络条件下的实用性。
      为网络请求划分优先顺序时，请让文本获得高于富媒体的获取优先级。
      文本请求往往体积更小、压缩率更高，因此传送速度更快。
    在低速连接条件下减少带宽使用 
      检测网络质量并调整您的应用的网络使用方式有助于带来出色的用户体验。
      ConnectivityManager> isActiveNetworkMetered() 
      ConnectivityManager> getActiveNetworkInfo() 
      ConnectivityManager> getNetworkCapabilities(Network) 
      TelephonyManager> getNetworkType()。
      在网速较慢时，请考虑只下载低分辨率媒体，或不下载任何媒体。
      使用调色板库生成与目标图像相符的占位符颜色，创建动态占位符。
      Android 7.0（API 级别 24）及更高版本系统的设备中，用户可以打开流量节省程序设置，帮助最大限度地减少数据流量的使用。
      Android 7.0 扩展 ConnectivityManager 的功能，使之能够检测流量节省程序设置。
      https://developer.android.google.cn/training/basics/network-ops/managing
    检测网络变化，然后更改应用行为 
      ConnectivityManager> getActiveNetworkInfo() 
      ConnectivityManager> getNetworkCapabilities(Network) 
      TelephonyManager> getDataState()
      在网络质量下降时，按比例减少请求的数量和大小。在连接质量改善时，可以按比例增加请求至最佳水平。
      质量较高的无限流量网络时，请考虑提前预取数据，以供日后使用。
      从用户体验的角度来看，这可能意味着新闻阅读器应用在使用 2G 网络时一次提取三篇文章，但在使用 WLAN 时则会一次提取二十篇文章。  
      当网络连接发生变化时，会发送广播 CONNECTIVITY_CHANGE。当您的应用在前台运行时，您可以调用 registerReceiver 来接收该广播。
      收到该广播后，您应该重新评估当前网络状态，并相应调整您的界面和网络使用。
      在应用退出或调用 unregisterNetworkCallback() 之前，应用会继续接收回调。
      您不应在清单中声明此接收器，因为此功能在 Android 7.0（API 级别 24）及更高版本系统中不可用。
      https://developer.android.google.cn/about/versions/nougat/android-7.0-changes#bg-opt
      CONNECTIVITY_ACTION 在API24中做了修改，API28彻底departed，一同被处理的还有 ACTION_NEW_PICTURE 或 ACTION_NEW_VIDEO
      https://developer.android.google.cn/topic/performance/background-optimization
      28之后对Android Vitals中的不良行为，系统会限制应用访问资源
      https://developer.android.google.cn/topic/performance/vitals
      24之后要正确使用 JobScheduler 和新的 WorkManager 提供的强大的机制，在满足指定条件时（例如连接到不按流量计费网络时）调度网络操作。
      JobScheduler 来响应对内容提供程序的更改。JobInfo 对象可封装 JobScheduler 用来调度作业的参数。当满足作业条件时，系统会在应用的 JobService 上执行此作业。
      对接收网络活动广播的限制  
        连接到不按流量计费的网络时调度网络作业
          当满足作业条件时，您的应用会收到一个回调，以运行指定的 JobService.class 中的 onStartJob() 方法。
          JobStessduler 的一个新替代工具是 JobManager，这个 API 可用来调度无论应用进程是否存在都需要保证完成的后台任务。
          WorkManager 根据设备 API 级别等因素选择运行工作的适当方式（直接在应用进程中的线程上以及使用 JobScheduler、FirebaseJobDispatcher 或 AlarmManager）。
          此外，WorkManager 不需要 Play 服务，并且提供多项高级功能，例如将任务链接在一起或检查任务状态。
          https://developer.android.google.cn/topic/libraries/architecture/workmanager
        在应用运行时监控网络连接
          正在运行的应用仍然可以通过已注册的 BroadcastReceiver 监听 CONNECTIVITY_CHANGE。
          不过，ConnectivityManager API 提供一个更强大的方法，用于仅在满足指定的网络条件时请求回调。
          NetworkRequest 对象在 NetworkCapabilities 方面定义网络回调的参数。
          您需要使用 NetworkRequest.Builder 类创建 NetworkRequest 对象。
          registerNetworkCallback() 随后将 NetworkRequest 对象传递给系统。
          满足网络条件时，应用会收到回调，以执行其 ConnectivityManager.NetworkCallback 类中定义的 onAvailable() 方法。
      对接收图片和视频广播的限制     
        通过扩展 JobInfo 和 JobParameters 提供了替代解决（API 级别 24）中，应用无法发送或接收 ACTION_NEW_PICTURE 或 ACTION_NEW_VIDEO 广播。
        内容 URI 发生更改时触发作业
          JobInfo.TriggerContentUri()
          当系统报告指定内容 URI 发生更改时，您的应用会收到回调，
          并且会有一个 JobParameters 对象传递给 MediaContentJob.class 中的 onStartJob() 方法。
        确定哪些内容授权方触发了作业 
          （API 级别 24）还扩展了 JobParameters，以允许您的应用接收有关哪些内容方和 URI 触发了该作业的有用信息
      （API 级别 24）引入了一些额外的 Android 调试桥 (ADB) 命令，供您在这些后台进程停用的情况下测试应用行为
        要模拟隐式广播和后台服务不可用的条件，请输入以下命令：
          adb shell cmd appops set <package_name> RUN_IN_BACKGROUND ignore
        要重新启用隐式广播和后台服务，请输入以下命令：
          adb shell cmd appops set <package_name> RUN_IN_BACKGROUND allow        

            
面向更广泛的设备
  减少应用所占用的内存，并针对各种设备功能开发应用。
  支持多种屏幕尺寸
    使用密度无关像素 (dp)
      相当于每英寸 160 点（中等像素密度）下像素的物理尺寸。
      dp 定义布局可确保界面的物理尺寸在任何设备上都保持一致。
      支持多种屏幕
      https://developer.android.google.cn/guide/practices/screens_support

    在 ldpi 和 mdpi 屏幕密度下测试文本和图形
      测试文本和图形以确保其在低密度和中密度（ldpi 和 mdpi）屏幕上正常显示，因为这些密度是常见密度，在低成本设备上更是如此。
      注意低密度屏幕上不清晰的文本，其中细节部分不可见。
      对于屏幕密度较低的设备，其硬件规格也往往较低。为确保您的应用在这些设备上顺利运行，请考虑降低或消除繁重的图形处理负载，如动画和转场。
      支持不同密度
      https://developer.android.google.cn/guide/practices/screens_support

    在中小型屏幕上测试布局
      通过在小屏幕上测试，验证您的布局能否按比例缩小。在屏幕尺寸缩减时，需要特别讲究可见界面元素，因为其空间有限。
      支持不同屏幕尺寸
      https://developer.android.google.cn/training/multiscreen/screensizes

  提供向后兼容性
    适当设置您的 targetSdkVersion 和 minSdkVersion
      targetSdkVersion 应为 Android 的最新版本。以最新版本为目标可确保运行更新版本的 Android 时，您的应用能够继承更新的运行时行为。
      minSdkVersion 用于设置支持的最低 Android 版本。使用 Android 4.0（API 级别 14：Ice Cream Sandwich）或 Android 4.1（API 级别 16：Jelly Bean）- 这些版本可最大程度地覆盖现代设备。设置 minSdkVersion 还会使 Android 构建工具报告旧版本平台上可能并未提供的新 API 的不正确使用情况。
  高效利用内存
    减少低成本设备上的内存占用
      动态调整内存占用可确保兼容内存配置不同的设备。
      isLowRamDevice() 和 getMemoryClass() 等方法有助于确定运行时内存约束。
      您可以根据这些信息按比例减少内存使用量。例如，您可以在低内存设备上使用低分辨率图像。
      管理应用内存
      https://developer.android.google.cn/topic/performance/memory
        监控可用内存和内存使用量
          释放内存以响应事件
            Android 可以通过多种方式从应用中回收内存，或在必要时完全终止应用，从而释放内存以执行关键任务。
            为了进一步帮助平衡系统内存并避免系统需要终止您的应用进程，您可以在 Activity 类中实现 ComponentCallbacks2 接口。
            借助所提供的 onTrimMemory() 回调方法，您的应用可以在处于前台或后台时监听与内存相关的事件，然后释放对象以响应指示系统需要回收内存的应用生命周期事件或系统事件。
          查看您应该使用多少内存
            为了允许多个进程同时运行，Android 针对为每个应用分配的堆大小设置了硬性限制。
            设备的确切堆大小限制因设备总体可用的 RAM 多少而异。
            如果您的应用已达到堆容量上限并尝试分配更多内存，系统就会抛出 OutOfMemoryError。
            为了避免用尽内存，您可以查询系统以确定当前设备上可用的堆空间。
            您可以通过调用 getMemoryInfo() 向系统查询此数值。
            它将返回一个 ActivityManager.MemoryInfo 对象，其中会提供与设备当前的内存状态有关的信息，
            包括可用内存、总内存和内存阈值（如果达到此内存级别，系统就会开始终止进程）。
            ActivityManager.MemoryInfo 对象还会提供一个简单的布尔值lowMemory，您可以根据此值确定设备是否内存不足。
        使用内存效率更高的代码结构
          谨慎使用服务
            在您启动某项服务后，系统更倾向于让此服务的进程始终保持运行状态。
            这种行为会导致服务进程代价十分高昂，因为一旦服务使用了某部分 RAM，那么这部分 RAM 就不再可供其他进程使用。
            这会减少系统可以在 LRU 缓存中保留的缓存进程数量，从而降低应用切换效率。
            当内存紧张，并且系统无法维护足够的进程以托管当前运行的所有服务时，这甚至可能导致系统出现颠簸。
            如果您的应用需要某项服务在后台执行工作，请不要让其保持运行状态，除非其需要运行作业。
            请注意在服务完成任务后使其停止运行。否则，您可能会在无意中导致内存泄漏。
            避免使用持久性服务，因为它们会对可用内存提出持续性的要求。
            采用 JobSchedulerJobScheduler 等替代实现方式
            如果您必须使用某项服务，则限制此服务的生命周期的最佳方式是使用 IntentService，它会在处理完启动它的 intent 后立即自行结束。
            https://developer.android.google.cn/guide/components/services
          使用经过优化的数据容器
            常规 HashMap 实现的内存效率可能十分低下，因为每个映射都需要分别对应一个单独的条目对象。
            Android 框架包含几个经过优化的数据容器，包括 SparseArray、SparseBooleanArray 和 LongSparseArray。 
            例如，SparseArray 类的效率更高，因为它们可以避免系统需要对键（有时还对值）进行自动装箱（这会为每个条目分别再创建 1-2 个对象）。
          谨慎对待代码抽象
            开发者往往会将抽象简单地当做一种良好的编程做法，因为抽象可以提高代码灵活性和维护性。
            不过，抽象的代价很高：通常它们需要更多的代码才能执行，需要更多的时间和更多的 RAM 才能将代码映射到内存中。
            因此，如果抽象没有带来显著的好处，您就应该避免使用抽象。
          针对序列化数据使用精简版 Protobuf
            协议缓冲区是 Google 设计的一种无关乎语言和平台，并且可扩展的机制，用于对结构化数据进行序列化。
            该机制与 XML 类似，但更小、更快也更简单。如果您决定针对数据使用 Protobuf，则应始终在客户端代码中使用精简版 Protobuf。
            常规 Protobuf 会生成极其冗长的代码，这会导致应用出现多种问题，例如 RAM 使用量增多、APK 大小显著增加以及执行速度变慢。
          避免内存抖动    
            如前所述，垃圾回收事件通常不会影响应用的性能。不过，如果在短时间内发生许多垃圾回收事件，就可能会快速耗尽帧时间。
            系统花在垃圾回收上的时间越多，能够花在呈现或流式传输音频等其他任务上的时间就越少。
            通常，“内存抖动”可能会导致出现大量的垃圾回收事件。实际上，内存抖动可以说明在给定时间内出现的已分配临时对象的数量。
            例如，您可以在 for 循环中分配多个临时对象。或者，您也可以在视图的 onDraw() 函数中创建新的 Paint 或 Bitmap 对象。
            在这两种情况下，应用都会快速创建大量对象。
            这些操作可以快速消耗新生代 (young generation) 区域中的所有可用内存，从而迫使垃圾回收事件发生。
            使用memory profiler查看java堆和内存分配
            https://developer.android.google.cn/studio/profile/memory-profiler
            考虑将某些代码逻辑从内部循环中移出，或将其移到基于 工厂模式 的分配结构中。
        移除会占用大量内存的资源和库
          缩减总体 APK 大小
            您可以通过缩减应用的总体大小来显著降低应用的内存使用量。
            位图大小、资源、动画帧数和第三方库都会影响 APK 的大小。
            Android Studio 和 Android SDK 提供了可帮助您缩减资源和外部依赖项大小的多种工具。
            这些工具支持现代代码收缩方法，例如 R8 编译。（Android Studio 3.3 及更低版本使用 ProGuard，而不是 R8 编译。）
            缩减应用大小
            https://developer.android.google.cn/topic/performance/reduce-apk-size
            R8配置
            https://developer.android.google.cn/studio/build/shrink-code#configuration-files
          使用 Dagger 2 实现依赖注入
            依赖注入框架可以简化您编写的代码，并提供一个可供您进行测试及其他配置更改的自适应环境。
            Dagger 不使用反射来扫描您应用的代码。
            Dagger 的静态编译时实现意味着它可以在 Android 应用中使用，而不会带来不必要的运行时代价或内存消耗量。  
            其他使用反射的依赖注入框架倾向于通过扫描代码中的注释来初始化进程。
            此过程可能需要更多的 CPU 周期和 RAM，并可能在应用启动时导致出现明显的延迟。
          谨慎使用外部库
            外部库代码通常不是针对移动环境编写的，在移动客户端上运行时可能效率低下。
            如果您决定使用外部库，则可能需要针对移动设备优化该库。
            在决定是否使用该库之前，请提前规划，并在代码大小和 RAM 消耗量方面对库进行分析。
            即使是一些针对移动设备进行了优化的库，也可能因实现方式不同而导致问题。
            例如，一个库可能使用的是精简版 Protobuf，而另一个库使用的是 Micro Protobuf，导致您的应用出现两种不同的 Protobuf 实现。
            日志记录、分析、图像加载框架和缓存以及许多您意料之外的其他功能的不同实现都可能导致这种情况。
            虽然 ProGuard 可以使用适当的标记移除 API 和资源，但无法移除库的大型内部依赖项。
            您所需要的这些库中的功能可能需要较低级别的依赖项。
            如果存在以下情况，这就特别容易导致出现问题：
              您使用某个库中的 Activity 子类（往往会有大量的依赖项）、
              库使用反射（这很常见，意味着您需要花费大量的时间手动调整 ProGuard 以使其运行）等。
            此外，请避免仅针对数十个功能中的一两个功能使用共享库。
            您一定不希望产生大量您甚至根本用不到的代码和开销。
            在考虑是否使用某个库时，请查找与您的需求十分契合的实现。否则，您可以决定自己去创建实现。  
      当然，您必须先在代码中找到内存抖动较高的位置，然后才能进行修复。
  针对运行 Android (Go edition) 的设备进行优化
    Android (Go edition) 是针对内存不超过 1GB 的入门级设备优化的系统，其中 Android Oreo (Go edition) 是最先推出的系统
      targetSdkVersion 应该是最新版本的 Android 系统。Android (Go edition) 设备只运行 Android Oreo（API 26 或更高版本）。
      应用应在内存不超过 1GB 的设备上流畅运行。记住上文高效利用内存中列出的内存优化方式，同时使用 Android Vitals 确定并修复渲染缓慢和帧冻结等不良行为。
      可在低内存设备上停用画中画 (PIP)。在您的应用使用 PIP 之前，先通过调用 hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE) 进行检查，以确保此功能可用。
      设备上应用的大小应小于 40MB。
      在应用的内存使用量中，按比例分配占用内存 (PSS) 量不能超过 50MB。对于游戏，在游戏的内存使用量中，PSS 量不能超过 150MB。
      参考memory profiler优化
      https://developer.android.google.cn/studio/profile/memory-profiler
      应尽可能缩短应用的启动时间，将其控制在 5 秒以内。

提供流量控制
  让用户可以掌控应用的流量使用，减小您的 APK 大小并关注流量消耗。
  缩减应用大小
    缩减 APK 图形化资产大小
      图形化资产往往对 APK 体积的影响最大。对其进行优化可以减少下载内容大小，从而缩短用户的安装时间。
      对于图标等图形化资产，请使用可缩放矢量图形 (SVG) 格式。SVG 图像的尺寸比位图图形小，可在运行时渲染至任何分辨率
      对于照片等非矢量图像，请使用 WebP 缩短图像加载时间，并节省网络带宽。WebP 经证明所生成的文件比 PNG 和 JPG 格式文件小，而图像质量却丝毫不差。
      如果您有许多大型图像采用多种密度，请考虑使用多重 APK 支持按密度拆分您的 APK。由此可生成多个针对特定密度的版本，这意味着使用低密度设备的用户无需因下载未使用的高密度资产而招致惩罚。
      多 APK 支持 （为应用发布不同的应用 APK，每个 APK 针对不同的设备配置）
      https://developer.android.google.cn/google/play/publishing/multiple-apks
      缩减 APK 大小和压缩代码与资源
      https://developer.android.google.cn/studio/build/shrink-code
      https://developer.android.google.cn/topic/performance/reduce-apk-size
    缩减代码大小
      Android 项目中的每个库都在向 APK 添加可能不会用到的代码。请谨慎使用外部库，因为并非所有库都可在移动应用中使用。确保您的应用使用的库已针对移动使用进行了优化。
      请考虑利用 ProGuard 等工具来优化您的编译代码。ProGuard 可以找出并移除 APK 中未使用的代码。此外，您还可以通过在 build.gradle 中设置 minifyEnabled=true、shrinkResources=true，在构建时实现资源缩减，这样做可以自动从您的 APK 中移除未使用的资源。
    允许将应用移至外部 (SD) 存储空间
      低成本设备自带的内置存储空间通常很小。用户可通过 SD 卡扩展存储空间；不过，应用需要明确声明其支持安装至外部存储，用户方可移动数据。
      您可利用您的 AndroidManifest.xml 中的 android:installLocation 标记，允许将您的应用安装至外部存储空间。
      应用安装位置
      https://developer.android.google.cn/guide/topics/data/install-location
    降低应用安装后的磁盘占用率
      让应用的磁盘占用率保持较低水平，意味着在设备的可用空间不足时，用户卸载应用的可能性较小。务必规定缓存的界限，如此可防止应用的磁盘占用率无限增长。请务必将您的缓存数据存放在 getCacheDir()，系统可以根据需要删除存放在此处的文件，这样它们就不会显示为应用专用存储内容。
  提供可配置的网络使用
    针对用户的网络选择提供加入体验
      即便对数据的要求很高，允许用户降低数据使用量的应用仍大受欢迎。如果您应用的带宽占用量相当大（例如，视频流式播放应用），可以为用户提供加入体验来配置网络使用。例如，您可以允许用户在使用蜂窝网络时强制播放比特率较低的视频流。
      其他供用户控制数据同步、预取和网络使用行为（例如，只在使用 Wi-Fi 网络时预取所有已加星标的新闻类别）的设置也有助于用户根据自身需求来定制应用的行为。
      管理网络使用情况
      https://developer.android.google.cn/training/basics/network-ops/managing
    提供网络首选项偏好设置 Activity
      您可以借助于网络首选项屏幕，从应用以外导航至应用的网络设置。您可以从系统设置屏幕或系统流量消耗屏幕调用该屏幕。
      要提供用户可在应用内以及从系统设置访问的网络首选项屏幕，请在您的应用中加入一个支持 ACTION_MANAGE_NETWORK_USAGE 操作的 Activity。
      实现偏好设置 Activity
      https://developer.android.google.cn/training/basics/network-ops/managing#prefs


高效使用电池
  为用户打造低电耗的体
  降低电池消耗
    1.在后台运行以及当设备靠电池电量运行时，您的应用应最大限度地减少 Activity。
    2.GPS 等传感器会消耗大量的电池电量。
    为避免这些问题，您可以使用 FusedLocationProvider API 来管理底层定位技术。
    其可提供简单的 API，以便您从高层次角度指定高准确率或低能耗等要求。
    获取最近一次的已知位置
    https://developer.android.google.cn/training/location/retrieve-current
    它还可以通过缓存位置和批处理跨应用请求来优化设备的电池电量消耗。
    优化下载以实现高效网络访问
    https://developer.android.google.cn/training/efficient-downloads/efficient-network-access
      无线装置状态机
      应用会如何影响无线装置状态机
      预先抓取数据
      批量传输和连接
      减少连接
      使用 Network Profiler 识别问题
    3.Wake lock 是让设备保持运行状态以便执行后台 Activity 的机制。请避免使用 Wake lock，因为其会阻止设备进入低能耗状态。
    https://developer.android.google.cn/reference/android/os/PowerManager.WakeLock
    4.要想减少设备的唤醒次数，请对网络 Activity 进行批处理。
    5.GcmNetworkManager 能够调度任务并允许 Google Play 服务对整个系统的操作执行批处理。
    这大大简化了常见模式的实现，如等待网络连接、设备充电状态、重试和退避。
    利用 GcmNetworkManager 在设备正在充电并连入无限流量网络时执行非必需的后台 Activity。
    6.减少网络耗电量
    https://developer.android.google.cn/topic/performance/power/network
      收集网络流量数据
      分析网络流量数据
      优化用户发起的网络使用
      优化应用发起的网络使用
      优化服务器发起的网络使用
      优化常规网络使用
  检测电池使用情况
    检测您的应用在受控环境下的电池使用情况有助于您了解在应用内执行哪些任务的电池消耗较大。
    通过检测应用的电池使用情况来衡量效率和追踪随时间变化的情况是一种很好的做法。
    Batterystats 可收集您的应用的相关电池数据，而 Battery Historian 可将这些数据转换为 HTML 可视化形式。
    battery historian工具
    https://developer.android.google.cn/tools/performance/batterystats-battery-historian
    优化电池续航时间
    https://developer.android.google.cn/topic/performance/power

界面和内容
  响应快速而灵敏的界面
    在所有可触摸项上提供触摸反馈
      1.触摸反馈可为用户界面增添一种触感。您应该确保应用在所有可触摸元素上都提供触摸反馈，以尽可能缩短感知的应用延迟时间。
      2.响应迅速的交互通过及时对用户输入作出符合逻辑并令人愉快的屏幕反应来鼓励用户对应用进行深入探索。响应迅速的交互将应用从信息提供服务提升至利用多种视觉和触觉响应进行沟通的体验层次。
      3.定制触摸反馈
      https://developer.android.google.cn/training/material/animations#Touch
    界面应始终具有交互性
      1.执行后台 Activity 时响应迟钝的应用会令人产生运行缓慢的感觉，并使用户满意度下降。
      确保您的应用界面在执行任何后台 Activity 时都能迅速响应。
      可通过在后台线程中执行网络操作或任何繁重负载操作（尽可能让界面线程保持空闲状态）来实现此目的。
      2.Material Design 应用通过使用单一 Activity 指示器表示每项操作，在加载内容时只使用最少量的视觉变化。避免通过加载指示器屏蔽对话。
      3.当视图没有内容显示时，就会出现空态。它可能表现为列表中不包含任何项目，或者搜索未返回任何结果。
      使用前言内容、教育内容或最佳匹配内容可避免空态。当这些选项不适用时，系统会显示非交互式图像和文本标语，让用户了解在有内容显示时他们会看到的具体内容。
      4.使应用能迅速响应
      https://developer.android.google.cn/training/articles/perf-anr
        什么会触发 ANR
          当应用无法响应用户输入时，系统即会显示 ANR。
          例如，如果应用在界面线程中屏蔽了某些 I/O 操作（通常是网络访问），导致系统无法处理传入的用户输入事件。
          或者，应用在界面线程中花费太多时间构建复杂的内存结构或计算游戏的下一个走法。
          确保高效的计算始终至关重要，但即使最高效的代码仍然需要时间来运行。
          应用面临任何可能需要执行冗长的操作的情况下，您不应在界面线程中执行这些操作，而是应该创建工作线程并在其中执行大部分操作。
          这样即可让界面线程（用于驱动界面事件循环）保持运行，并阻止系统断定您的代码已卡住。
          由于这种线程通常是在类级别完成的，因此您可以将响应能力视为一种类问题。
          在 Android 中，应用响应性由 Activity 管理器和窗口管理器系统服务监控。
          当 Android 检测到以下某一项条件时，便会针对特定应用显示 ANR 对话框：
            在 5 秒内对输入事件（例如按键或屏幕轻触事件）没有响应。
            BroadcastReceiver 在 10 秒后尚未执行完毕。
        如何避免 ANR
          Android 应用通常完全在单个线程中运行（默认为“界面线程”或“主线程”）。
          这意味着应用在界面线程中执行的任何需要很长时间才能完成的操作都可能会触发 ANR 对话框，因为应用没有给自己处理输入事件或 intent 广播的机会。
          因此，在界面线程中运行的所有方法都应该尽可能减少在此线程中的操作。
          特别是在 onCreate() 和 onResume() 等关键生命周期方法中，Activity 应尽量减少进行设置所需的操作。
          可能会长时间运行的操作（例如网络或数据库操作）或计算成本高昂的计算（例如调整位图大小）应在工作线程中完成（如果是数据库操作，则应通过异步请求完成）。
          为耗时较长的操作创建工作线程的最有效方法是使用 AsyncTask 类。
          只需扩展 AsyncTask 并实现 doInBackground() 方法即可执行相应操作。
          要向用户发布进度变化，您可以调用 publishProgress()，它会调用 onProgressUpdate() 回调方法。
          通过 onProgressUpdate()（在界面线程中运行）的实现，您可以向用户发送通知。
          虽然比 AsyncTask 复杂，但您可能想要创建自己的 Thread 或 HandlerThread 类。如
          果是这样，您应该调用 Process.setThreadPriority() 并传递 THREAD_PRIORITY_BACKGROUND，从而将线程优先级设为“后台”优先。
          如果您不通过这种方式将线程设为较低的优先级，则此线程仍可能会让应用变慢，因为默认情况下，此线程会按照与界面线程相同的优先级操作。
          如果您实现了 Thread 或 HandlerThread，请确保在等待工作线程完成操作期间，界面线程不会阻塞；
          请勿调用 Thread.wait() 或 Thread.sleep()。
          非但不应在等待工作线程完成操作期间阻塞，主线程在完成操作时还应提供 Handler 以供其他线程向回发送。
          以这种方式设计应用，即可让应用的界面线程对输入保持响应，从而避免因 5 秒的输入事件超时而导致系统显示 ANR 对话框。
          对 BroadcastReceiver 执行时间的特定约束强调了广播接收器的功能：
          在后台执行少量离散工作，例如保存设置或注册 Notification。
          因此，与在界面线程中调用的其他方法一样，应用应避免在广播接收器中执行可能会长时间运行的操作或计算。
          但如果需要执行可能需要长时间运行的操作以响应 intent 广播，则应用应启动 IntentService，而不是通过工作线程执行密集型操作。
          BroadcastReceiver 对象的另一个常见问题会在其频繁执行时出现。频繁的后台执行可能会减少其他应用可用的内存量
          随需操纵广播接收器
          https://developer.android.google.cn/training/monitoring-device-state/manifest-receivers
          使用 StrictMode 查找可能会长时间运行的操作，例如您可能会无意中在主线程中执行的网络或数据库操作。
          https://developer.android.google.cn/reference/android/os/StrictMode
        加强响应能力
          如果应用在后台执行操作以响应用户输入，则显示正在进行该操作（例如在界面中使用 ProgressBar）。
          特别是游戏，在工作线程中计算走法。
          如果应用具有耗时较长的初始设置阶段，考虑显示启动画面或尽快呈现主视图，表明正在加载，并异步填充信息。
          在任何一种情况下，您都应以某种方式表明操作正在进行，以免用户认为应用已卡住。
          使用 Systrace 和 Traceview 等性能工具确定应用响应能力方面的瓶颈。
          Systrace
          https://developer.android.google.cn/topic/performance/tracing/command-line
          Traceview在android studio 3.2被废弃，推荐使用 CPU Profiler 
          https://developer.android.google.cn/studio/profile/traceview
          使用 CPU Profiler 检查 CPU 活动
          https://developer.android.google.cn/studio/profile/cpu-profiler
    以 60 帧/秒作为低成本设备上的目标
      1.确保您的应用始终快速而又顺畅地运行，即便是低成本设备也不例外。
      2.过度绘制会严重拖慢应用的运行速度 - 每一遍对像素进行多次绘制时就会发生这种情况。
      例如，图像上面放置有按钮就属于这种情况。尽管某些过度绘制不可避免，仍应尽量减少，以确保帧率平稳。
      对您的应用执行 GPU 过度绘制调试，以确保最大限度地减少过度绘制。
      GPU 过度绘制调试
      https://developer.android.google.cn/topic/performance/rendering/inspect-gpu-rendering
      3.Android 设备按 60 帧/秒 (fps) 帧率刷新屏幕，这意味着您的应用需要在大约 16 毫秒内更新屏幕。
      手机内置渲染帧率工具
      https://developer.android.google.cn/topic/performance/rendering/inspect-gpu-rendering#profile_rendering
      4.在低成本设备上减少或取消动画，以降低设备 CPU 和 GPU 的负荷。
      改善布局性能
      https://developer.android.google.cn/training/improving-layouts
      5.高效的视图层次可以加快您的应用速度，而不会增加应用的内存占用。
      性能与视图层次结构
      https://developer.android.google.cn/topic/performance/rendering/optimizing-view-hierarchies
    在应用启动速度缓慢时使用启动屏幕
      1.启动屏幕是用户对应用的第一体验。启动您的应用时显示空白画布会延长其感知加载时间，因此请考虑使用占位符界面或品牌启动屏幕来缩短感知加载时间。
      2.占位符界面是最无缝化的启动过渡方式，适用于应用启动和应用内 Activity 过渡。
      3.品牌启动屏幕可提供短暂的品牌曝光，从而解放界面，将注意力集中在内容上。
      4.解决启动速度缓慢问题的最佳方法是不启动这些应用。启动时间性能提供有助于缩短应用启动时间的信息
      https://developer.android.google.cn/topic/performance/vitals/launch-time
      5.使用 Material Design 
      https://material.io/design/
  界面最佳做法
    Material Design https://material.io/design/
    Material Design 支持库
  本地化           
    您的用户可能来自全球任何地方，使用的可能并非是您的母语。如果您推出的应用未采用用户能够读懂的语言，便会错失机会。因此，您应该针对重要的地区语言将应用本地化。
    支持不同的语言和文化
    https://developer.android.google.cn/training/basics/supporting-devices/languages
    从 Android 7.0（API 级别 24）开始，Android 框架提供部分 ICU4J API，这些 API 可帮助您将应用本地化为多种语言。
    ICU4J Android 框架 API
    https://developer.android.google.cn/guide/topics/resources/icu4j-framework

##### Android6.0权限动态申请

此博客主要谈谈Android6.0的权限，关于其他6.0的知识 请看https://developer.android.com/about/versions/marshmallow/android-6.0.html

Android将权限分为正常权限 和 危险权限

Android系统权限分为几个保护级别。需要了解的两个最重要保护级别是 正常权限 和 危险权限:

（1）正常权限:

涵盖应用需要访问其沙盒外部数据或资源，但对用户隐私或其他应用操作风险很小的区域。

这些权限在应用安装时授予，运行时不再询问用户。例如: 网络访问、WIFI状态、音量设置等。

（2）危险权限:

涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。

例如: 读取通讯录、读写存储器数据、获取用户位置等。如果应用声明需要这些危险权限，则必须在运行时明确告诉用户，让用户手动授予。

 

Android系统对所有的危险权限进行了分组，称为 权限组 。

属于同一组的危险权限将自动合并授予，用户授予应用某个权限组的权限，则应用将获得该权限组下的所有权限（前提是相关权限在 AndroidManifest.xml 中有声明）。

 

正常权限：和原来的使用方式一样，只需在AndroidManifest.xml中添加即可

危险权限：要使用的话就要申请了，（前提是相关权限在 AndroidManifest.xml 中也要有声明）通过Java代码申请。

 

权限表

 

访问登记属性 android.permission.ACCESS_CHECKIN_PROPERTIES ，读取或写入登记check-in数据库属性表的权限
获取错略位置 android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米
获取精确位置 android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内
获取模拟定位信息 android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用
获取网络状态 android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效
访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图
获取WiFi状态 android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息
账户管理 android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限
验证账户 android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息
电量统计 android.permission.BATTERY_STATS，获取电池电量统计信息
绑定小插件 android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限
绑定设备管理 android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用
绑定输入法 android.permission.BIND_INPUT_METHOD ，请求InputMethodService服务，只有系统才能使用
绑定RemoteView android.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用
绑定壁纸 android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用
使用蓝牙 android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备
蓝牙管理 android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备
变成砖头 android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头
应用删除时广播 android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播
收到短信时广播 android.permission.BROADCAST_SMS，当收到短信时触发一个广播
连续广播 android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播
WAP PUSH广播 android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播
拨打电话 android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码
通话权限 android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面
拍照权限 android.permission.CAMERA，允许访问摄像头进行拍照
改变组件状态 android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态
改变配置 android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位
改变网络状态 android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网
改变WiFi多播状态 android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态
改变WiFi状态 android.permission.CHANGE_WIFI_STATE，改变WiFi状态
清除应用缓存 android.permission.CLEAR_APP_CACHE，清除应用缓存
清除用户数据 android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据
底层访问权限 android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息
手机优化大师扩展权限 android.permission.CELL_PHONE_MASTER_EX，手机优化大师扩展权限
控制定位更新 android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变
删除缓存文件 android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件
删除应用 android.permission.DELETE_PACKAGES，允许程序删除应用
电源管理 android.permission.DEVICE_POWER，允许访问底层电源管理
应用诊断 android.permission.DIAGNOSTIC，允许程序到RW到诊断资源
禁用键盘锁 android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁
转存系统信息 android.permission.DUMP，允许程序获取系统dump信息从系统服务
状态栏控制 android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏
工厂测试模式 android.permission.FACTORY_TEST，允许程序运行工厂测试模式
使用闪光灯 android.permission.FLASHLIGHT，允许访问闪光灯
强制后退 android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层
访问账户Gmail列表 android.permission.GET_ACCOUNTS，访问GMail账户列表
获取应用大小 android.permission.GET_PACKAGE_SIZE，获取应用的文件大小
获取任务信息 android.permission.GET_TASKS，允许程序获取当前或最近运行的应用
允许全局搜索 android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能
硬件测试 android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试
注射事件 android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流
安装定位提供 android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供
安装应用程序 android.permission.INSTALL_PACKAGES，允许程序安装应用
内部系统窗口 android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限
访问网络 android.permission.INTERNET，访问网络连接，可能产生GPRS流量
结束后台进程 android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程
管理账户 android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表
管理程序引用 android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统
高级权限 android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限
社区权限 android.permission.MTWEAK_FORUM，允许使用mTweak社区权限
软格式化 android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息
修改声音设置 android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息
修改电话状态 android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面
格式化文件系统 android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡
挂载文件系统 android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统
允许NFC通讯 android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持
永久Activity android.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除
处理拨出电话 android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话
读取日程提醒 android.permission.READ_CALENDAR，允许程序读取用户的日程信息
读取联系人 android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息
屏幕截图 android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图
读取收藏夹和历史记录 com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录
读取输入状态 android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统
读取系统日志 android.permission.READ_LOGS，读取系统底层日志
读取电话状态 android.permission.READ_PHONE_STATE，访问电话状态
读取短信内容 android.permission.READ_SMS，读取短信内容
读取同步设置 android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置
读取同步状态 android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态
重启设备 android.permission.REBOOT，允许程序重新启动设备
开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行
接收彩信 android.permission.RECEIVE_MMS，接收彩信
接收短信 android.permission.RECEIVE_SMS，接收短信
接收Wap Push android.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息
录音 android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克
排序系统任务 android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务
结束系统任务 android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃
发送短信 android.permission.SEND_SMS，发送短信
设置Activity观察其 android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试
设置闹铃提醒 com.android.alarm.permission.SET_ALARM，设置闹铃提醒
设置总是退出 android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出
设置动画缩放 android.permission.SET_ANIMATION_SCALE，设置全局动画缩放
设置调试程序 android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发
设置屏幕方向 android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用
设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍
设置进程限制 android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制
设置系统时间 android.permission.SET_TIME，设置系统时间
设置系统时区 android.permission.SET_TIME_ZONE，设置系统时区
设置桌面壁纸 android.permission.SET_WALLPAPER，设置桌面壁纸
设置壁纸建议 android.permission.SET_WALLPAPER_HINTS，设置壁纸建议
发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号
状态栏控制 android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏
访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库
写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库
显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口
更新设备状态 android.permission.UPDATE_DEVICE_STATS，更新设备状态
使用证书 android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager
使用SIP视频 android.permission.USE_SIP，允许程序使用SIP视频服务
使用振动 android.permission.VIBRATE，允许振动
唤醒锁定 android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行
写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置
写入日程提醒 android.permission.WRITE_CALENDAR，写入日程，但不可读取
写入联系人 android.permission.WRITE_CONTACTS，写入联系人，但不可读取
写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件
写入Google地图数据 android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据
写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取
读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项
读写系统设置 android.permission.WRITE_SETTINGS，允许读写系统设置项
编写短信 android.permission.WRITE_SMS，允许编写短信
写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置
 

 

危险权限（官方文档的表 官网表：https://developer.android.com/guide/topics/security/permissions.html#normal-dangerous）


中文翻译过来如下：

group:android.permission-group.CALENDAR 日历
　 permission:android.permission.READ_CALENDAR 读取日历
　 permission:android.permission.WRITE_CALENDAR 写入日历

group:android.permission-group.CAMERA 照相机
　 permission:android.permission.CAMERA

group:android.permission-group.CONTACTS 通讯录方面
　 permission:android.permission.WRITE_CONTACTS 写入通讯录
　 permission:android.permission.GET_ACCOUNTS 访问通讯录权限
　 permission:android.permission.READ_CONTACTS 读取通讯录

group:android.permission-group.LOCATION 位置
　 permission:android.permission.ACCESS_FINE_LOCATION 获取位置
　 permission:android.permission.ACCESS_COARSE_LOCATION 获取粗略定位

group:android.permission-group.MICROPHONE 扩音器；麦克风
permission:android.permission.RECORD_AUDIO 录音

group:android.permission-group.PHONE 电话方面
　 permission:android.permission.READ_CALL_LOG 看电话记录
　 permission:android.permission.READ_PHONE_STATE 读取手机状态
　 permission:android.permission.CALL_PHONE 打电话
　 permission:android.permission.WRITE_CALL_LOG 编写调用日志
　 permission:android.permission.USE_SIP 使用SIP
　 permission:android.permission.PROCESS_OUTGOING_CALLS 过程输出调用 　 permission:com.android.voicemail.permission.ADD_VOICEMAIL 添加语音信箱

group:android.permission-group.SENSORS 传感器
　 permission:android.permission.BODY_SENSORS 体传感器
　
group:android.permission-group.SMS 信息
　permission:android.permission.READ_SMS 读取信息 　　
　 permission:android.permission.RECEIVE_WAP_PUSH 收到WAP推送
　 permission:android.permission.RECEIVE_MMS 接收彩信
　 permission:android.permission.RECEIVE_SMS 收信息
　 permission:android.permission.SEND_SMS 发信息
　 permission:android.permission.READ_CELL_BROADCASTS 读广播

group:android.permission-group.STORAGE 存储
　 permission:android.permission.READ_EXTERNAL_STORAGE 读取外部存储器 　
　 permission:android.permission.WRITE_EXTERNAL_STORAGE 写外部存储器

##### 动画场景转换

LOLLIPOP以前
overridePendingTransition (int enterAnim, int exitAnim)

LOLLIPOP以及之后(共享元素)
ActivityOptionsCompat.makeSceneTransitionAnimation(Activity target_activity, Pair<View, String>... pair_data);
在启动Activity中：
ActivityOptionsCompat activityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(
                this,
                //平滑的将多个控件平移的过渡到第二个activity
                //如下，将两个控件R.id.imageview_item与R.id.textview_name平移
                //根据需要，可以平移更多的控件。
                new Pair<View, String>(view.findViewById(R.id.imageview_item),
                        DetailActivity.VIEW_NAME_HEADER_IMAGE),
                new Pair<View, String>(view.findViewById(R.id.textview_name),
                        DetailActivity.VIEW_NAME_HEADER_TITLE));

        // Now we can start the Activity, providing the activity options as a bundle
        ActivityCompat.startActivity(this, intent, activityOptions.toBundle());
接收的Activity：
//获取本界面中两个对应的布局控件
mHeaderImageView = (ImageView) findViewById(R.id.imageview_header);
mHeaderTitle = (TextView) findViewById(R.id.textview_title);
/**
* 设置被共享的控件，由上一个Activity传入，通过自定义常量标识获取（VIEW_NAME_HEADER_IMAGE）
* Set the name of the view's which will be transition to, using the static values above.
* This could be done in the layout XML, but exposing it via static variables allows easy
* querying from other Activities
**/
ViewCompat.setTransitionName(mHeaderImageView, VIEW_NAME_HEADER_IMAGE);
ViewCompat.setTransitionName(mHeaderTitle, VIEW_NAME_HEADER_TITLE);

android.support.v4下的三个类:
ActivityOptionsCompat,    ActivityCompat,    ViewCompat


gv.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
 
                //获取数据(AdapterView的getItemAtPosition调用的就是Adapter的getItem()....我才知道...)
                Item item = (Item) parent.getItemAtPosition(position);
 
                Intent intent = new Intent(MainActivity.this, DetailActivity.class);
                //传入选中的Item对应的ID
                intent.putExtra(DetailActivity.EXTRA_PARAM_ID, item.getId());
 
                //主要的语句
                //通过makeSceneTransitionAnimation传入多个Pair
                //每个Pair将一个当前Activity的View和目标Activity中的一个Key绑定起来
                //在目标Activity中会调用这个Key
                ActivityOptionsCompat activityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(
                        MainActivity.this,
                        new Pair<View, String>(view.findViewById(R.id.id_iv),
                                DetailActivity.VIEW_NAME_HEADER_IMAGE),
                        new Pair<View, String>(view.findViewById(R.id.id_tv),
                                DetailActivity.VIEW_NAME_HEADER_TITLE));
 
                // ActivityCompat是android支持库中用来适应不同android版本的
                ActivityCompat.startActivity(MainActivity.this, intent, activityOptions.toBundle());
            }
});

ActivityOptionsCompat.makeSceneTransitionAnimation;

这句话创建了一个用于绑定两个Activity之间共享的View的key-value对, 说是共享View其实还是两个Activity各有一个View;

我们只是将这两个Activity中的View用同一个Key(String)绑定了, 然后系统会自动帮我们生成切换动画;



在DetailActivity也就是要跳转的Activity中也有几句重要的语句:
private void initView(){
        TransparentStyle.setTransparentStyle(this, R.color.color_primary);
        ViewHelper.initActionBar(this, getSupportActionBar(), "Transition");
        mHeaderImageView = (ImageView) findViewById(R.id.id_iv);
        mHeaderTitle = (TextView) findViewById(R.id.id_tv_title);
 
        //加载图片
        Picasso.with(mHeaderImageView.getContext())
                .load(mItem.getPhotoUrl())
                .noFade()
                .placeholder(R.mipmap.ic_launcher)
                .into(mHeaderImageView);
 
        //主要的语句---将当前Activity的View和自己定义的Key绑定起来
        ViewCompat.setTransitionName(mHeaderImageView, VIEW_NAME_HEADER_IMAGE);
        ViewCompat.setTransitionName(mHeaderTitle, VIEW_NAME_HEADER_TITLE);
}

其中的VIEW_Name_XXX就是我们要用来绑定的Key



google的一个示例app模仿的 
https://github.com/googlesamples/android-ActivitySceneTransitionBasic
本代码出处
https://github.com/ssthouse/MySceneTransitionTest

##### 自定义view的自定义属性方法
一般自定义view以达到某些效果，复写onDraw()方法就行了。当我们需要动态地响应用户的操作且能像Android自带View那样直接操作属性就很方便了，为了达到这个目的，我们就可以使用自定义view属性的方法来对我们的自定义view进行动态响应了。

 　　为了实现自定义的view的自定义属性，应该完成这四步:

为你的view在资源标签下定义自设的属性
在你的XML layout中指定属性值
在运行时获取属性值
把获取到的属性值应用在你的view上
step1：

 　　在资源标签下定义自设的属性，放置于res/values/attrs.xml文件中。下面是一个attrs.xml文件的示例:

复制代码
1 <resources>
2    <declare-styleable name="PieChart">
3        <attr name="showText" format="boolean" />
4        <attr name="labelPosition" format="enum">
5            <enum name="left" value="0"/>
6            <enum name="right" value="1"/>
7        </attr>
8    </declare-styleable>
9 </resources>
复制代码
　　上面的代码声明了2个自设的属性，showText与labelPosition，它们都归属于PieChart的项目下的styleable实例。styleable实例的名字，通常与自定义的view名字一致。当然你也可以不一致。

step2：

　　一旦你定义了自设的属性，你就可以在layout XML文件中使用它们。唯一不同的是你自设的属性是归属于自己项目的命名空间。不是属于http://schemas.android.com/apk/res/android的命名空间，它们归属于http://schemas.android.com/apk/res/[your package name]。例如，下面演示了如何为PieChart使用上面定义的属性：

复制代码
1 <?xml version="1.0" encoding="utf-8"?>
2 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
3    xmlns:custom="http://schemas.android.com/apk/res/com.example.customviews">
4  <com.example.customviews.charting.PieChart
5      custom:showText="true"
6      custom:labelPosition="left" />
7 </LinearLayout>
复制代码
　　为了避免输入长串的namespace名字，示例上面参考android别名的方法，使用了custom作为别名，你也可以选择其他的名称所为你的namespace，这只是一个变量名。请注意，如果你的view是一个内部类，你必须指定这个view的外部类。同样的，如果PieChart有一个内部类叫做PieView。为了使用这个类中自设的属性，你应该使用com.example.customviews.charting.PieChart$PieView.

step3：

　　在运行时获取属性值，当view从XML layout被创建的时候，在xml标签下的属性值都是从resource下读取出来并传递到view的构造方法中作为一个AttributeSet参数。我们通过obtainStyledAttributes()来获取属性值。这个方法会传递一个TypedArray对象。view通过TypedArray对象解析出属性值。

复制代码
 1 public PieChart(Context context, AttributeSet attrs) {
 2    super(context, attrs);
 3    TypedArray a = context.getTheme().obtainStyledAttributes(
 4         attrs,
 5         R.styleable.PieChart,
 6         0, 0);
 7 
 8    try {
 9        mShowText = a.getBoolean(R.styleable.PieChart_showText, false);
10        mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, 0);
11    } finally {
12        a.recycle();
13    }
14 }
复制代码
　　ps：注意TypedArray对象是一个公共资源，必须被在使用后进行回收。

step4：

　　从构造方法中获取到自定义属性，我们就可以应用自定义属性了。为了动态地实现一些view效果，我们可以放出getter 与setter方法来达到目的：

复制代码
1 public boolean isShowText() {
2    return mShowText;
3 }
4 
5 public void setShowText(boolean showText) {
6    mShowText = showText;
7    invalidate();
8    requestLayout();
9 }
复制代码
　　请注意，在setShowText方法里面有调用invalidate()) and requestLayout()). 当view的某些内容发生变化的时候，需要调用invalidate来通知系统对这个view进行重新绘制，当某些元素变化会引起组件大小变化时，需要调用requestLayout方法。


##### AMS的startActivity分析
AMS由system_server的ServerThread线程创建，在创建时有四个非常重要的过程：

1.调用AMS的main函数，得到一个context对象

1 context = ActivityManagerService.main(factoryTest);
2.调用setSystemProcess函数，这样可以把system_server进程加到AMS中作统一管理

1 ActivityManagerService.setSystemProcess();
3.调用installSystemProviders函数，把SettingProvider放到system_server进程中来运行

1 ActivityManagerService.installSystemProviders()
4.AMS准备好之后，启动systemReady线程来整个系统的启动

复制代码
1 ActivityManagerService.self().systemReady(new Runable() {
2     public void run() {
3       startSystemUi(contextF);//启动systemUI，准备状态栏
4       ...
5       Watchdog.getInstance().start();//启动Watchdog
6       ...//调用其他服务的systemReady函数
7    }
复制代码
AMS的main函数主要的工作是：

1.创建AMS对象；

2.创建一个供system_server进程使用的Android运行环境。这个比较隐晦，这个Android运行环境主要包括两个类成员：ActivityThread 和 ContextImpl 。

其中Activitythread 就是大名鼎鼎的进程的主线程了，ContextImpl 代表的是一个上下文环境，通过它们的类成员可以简单的知道它们的作用。

复制代码
ActivityThread
---------------
-mSystemContext: ContextImpl
-mLooper: Looper // 消息循环
-mServices: HashMap<IBinder,Service> //用于保存Service
-mInitialApplication: Application
-mAllApplications: ArrayList<Application> //用于保存Application
-mActivites: HashMap<IBinder,ActivityClientRecord> //保存ActivityClientRecord
复制代码
复制代码
ContextImpl
--------------
-mResources: Resources
-mPackageInfo : LoadedApk 
-mMainThread: ActivityThread
-mDatabaseDir: File
-mFileDir: File
复制代码
对于ContextImpl ，其成员变量表明它和资源、APK文件有关


AMS的setSystemProcess函数

setSystemProcess函数主要的工作是

1.注册AMS、MemBinder(内存信息)、GraphicsBinder(硬件加速信息)、CpuBinder、PermissionController（权限控制）等服务到ServiceManager中.

2.根据PackageManagerService返回的ApplicationInfo初始化Android运行环境，并创建一个代表system_server进程的ProcessRecord，从此，system_server进程也并入AMS的管理范围内了。

installSystemProviders函数
其实这个函数就是用于启动SettingProvider，并把其并入到system_server 所在进程中，由于system_server进程已经加载了framework-res.apk，现在又要加载SettingProviders.apk，这里是同一个进程加载两个apk的情形，两者uid都是“system”。因为system_server进程中很多Service都依赖Settings数据库，放在同一进程中可以降低进程间通信带来的效率损失。

AMS的systemReady分析
systemReady函数主要负责启动整个系统，包括一些准备工作，内容很多，大概有这么几步：

1.发送并处理与PRE_BOOT_COMPLETED广播相关的事情

2.杀死哪些在AMS还未启动完毕就先启动的应用进程，这些进程是APK所在的java进程，而不是Native 进程

3.从Setting数据库中获取配置信息，主要是debug_app、wait_for_debugger、always_finish_activities、font_scale

4.调用systemReady设置的回调对象goingCallback的run函数，这个函数主要是启动systemUIService，启动watchdog等

5.启动那些声明了persistent的APK。

6.启动桌面，发送BOOT_COMPLETED广播。

AMS的startActivity最终是调用的startActivityAndWait来处理启动请求的：

复制代码
 1     @Override
 2     public final WaitResult startActivityAndWait(
 3         IApplicationThread caller, //在多数情况下，一个Activity是由一个应用进程发起的，IApplicationThread是应用进程和AMS交互的通道，也可算是调用进程的标识
 4         String callingPackage,//调用的包名，即发起启动请求的包名
 5         Intent intent, 
 6         String resolvedType, 
 7         IBinder resultTo, //用于接收startActivityForResult的结果
 8         String resultWho, 
 9         int requestCode,//这个是调用者来定义其意义，若值大于等于0，则AMS内部保存该值并通过onActivityResult返回调用者
10         int startFlags, 
11         ProfilerInfo profilerInfo,//性能统计相关 
12         Bundle options, 
13         int userId//用户id
14         ) {
15         enforceNotIsolatedCaller("startActivityAndWait");
16         userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,
17                 false, ALLOW_FULL_ONLY, "startActivityAndWait", null);
18         WaitResult res = new WaitResult();//创建WaitResult对象用于保存处理结果
19         // TODO: Switch to user app stacks here.mStackSupervisor是ActivityStack类型
20         mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType,
21                 null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, res, null,
22                 options, userId, null, null);
23         return res;
24     }
复制代码
至此我们知道Activity是由ActivityStack来调度的，ActivityStack类是Activity调度的核心角色。这里关乎Android的task，back stack，ActivityStack 及launch mode的东西，是Android调度Activity及task的核心管理方法。ActivityStack有两个核心成员，我们通过一个表格来表明其意义。

ActivityRecord //Activity由ActivityRecord表示
---------------
-state: ActivityState //表示该Activity的状态（RESUMED.PAUSED等）
-app: ProcessRecord //指向该Activity所在的进程
-task: TaskRecord //指向该Activity所在的task
+stack: ActivityStack //指向管理此Activity的ActivityStack
TaskRecord //表示一个task
-------------
-taskId ：int //此task的id编号
-intent： Intent 
-numAcitivities：int //此task中的Activity数目
ActivityStack //Activity所处的栈
--------------
-mMainStack： boolean //表示此栈是否为主ActivityStack
-mHistory ：ArrayList<ActivityRecord> //这里保存了所有的Task的ActivityRecord
我们从它们三者的关系能够看到，ActivityStack采用数组的方式保存所有Task的ActivityRecord，并且没有成员维护TaskRecord。然而ActivityStack是靠维护栈来调度Activity，所以这种管理一来少了TaskRecord的管理，开销少，二来弱化了Task的概念，结构不够清晰。
startActivityAndWait > startActivityMayWait

startActivityMayWait 包含了如下主要工作：

1. 通过PKMS 查找匹配改Intent的ActivityInfo。

1         // Collect information about the target of the Intent.
2         ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,
3                 profilerInfo, userId);
2. 获取调用者的pid 和 uid

复制代码
 1 synchronized (mService) {
 2             final int realCallingPid = Binder.getCallingPid();
 3             final int realCallingUid = Binder.getCallingUid();
 4             int callingPid;
 5             if (callingUid >= 0) {
 6                 callingPid = -1;
 7             } else if (caller == null) {
 8                 callingPid = realCallingPid;
 9                 callingUid = realCallingUid;
10             } else {
11                 callingPid = callingUid = -1;
12             }
复制代码
3. 启动Activity的核心函数startActivityLocked .后面会说这个

1 int res = startActivityLocked(caller, intent, resolvedType, aInfo,
2                     voiceSession, voiceInteractor, resultTo, resultWho,
3                     requestCode, callingPid, callingUid, callingPackage,
4                     realCallingPid, realCallingUid, startFlags, options,
5                     componentSpecified, null, container, inTask);
 

4. 根据返回值做一些处理，此处在res返回成功时也需要等待是因为目标Activity要运行在一个新的应用进程中，就必须等待那个应用进程正常启动并处理相关请求。

复制代码
 1 if (outResult != null) {
 2                 outResult.result = res;
 3                 if (res == ActivityManager.START_SUCCESS) {
 4                     mWaitingActivityLaunched.add(outResult);
 5                     do {
 6                         try {
 7                             mService.wait(); //等待启动结果
 8                         } catch (InterruptedException e) {
 9                         }
10                     } while (!outResult.timeout && outResult.who == null);
11                 } else if 
12 。。。。
复制代码
startActivityMayWait > startActivityLocked

startActivityLocked分析

startActivityLocked主要工作包括：

1. 处理 sourceRecord（发起本次请求的Activity） 及 ResultRecord（接收处理结果的Activity），一般情况下两者是一样的。

复制代码
 1         ActivityRecord sourceRecord = null;
 2         ActivityRecord resultRecord = null;
 3         if (resultTo != null) {
 4             sourceRecord = isInAnyStackLocked(resultTo);
 5             if (DEBUG_RESULTS) Slog.v(
 6                 TAG, "Will send result to " + resultTo + " " + sourceRecord);
 7             if (sourceRecord != null) {
 8                 if (requestCode >= 0 && !sourceRecord.finishing) {
 9                     resultRecord = sourceRecord;
10                 }
11             }
12         }
复制代码
2.处理app switch ，如果AMS当前禁止app switch，则只能把本次启动请求保存起来。
关于AMS禁止app switch，是考虑到当某些重要（例如设置账号等）Activity处于前台，不希望系统因用户操作之外的原因切换Activity而设立的机制。

3. 调用startActivityUncheckedLocked作后续处理

        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,
                startFlags, true, options, inTask);
startActivityUncheckedLocked函数分析

startActivityUncheckedLocked的目的简单，就是为新创建的ActivityRecord找到一个合适的Task。

1.首先确定是否需要为新的Activity创建一个Task，即是否设置FLAG_ACTIVITY_NEW_TASK标志位，代码较多就不贴了。

2.创建一个新的TaskRecord，并调用startActivityLocked函数进行处理，在startActivityLocked函数中，把新的ActivityRecord添加到ActivityStack的mHistory数组里。最终调用resumeTopActivitiesLocked来启动Activity。resumeTopActivitiesLocke会判断mResumeActivity是否为空，当为空时会启动startSpecificActivityLocked函数来创建一个应用进程。在startSpecificActivityLocked中直接调用startProcessLocked函数来创建一个新的应用进程。

        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                "activity", r.intent.getComponent(), false, false, true);
在startProcessLocked中代码较多，其主要工作是通过发送消息给Zygote以派生出一个应用进程，这个新的应用进程便启动起来了。接下来就是这个新的应用进程和此前需要启动的Activity绑定的一个过程了。
> AMS的进程管理
Android将应用进程分为五大类，分别为Forground类、Visible类、Service类、Background类及Empty类。这五大类划分各有规则。

Forground类进程

该类进程重要性最高，想成为这一类进程需要满足下面的属性：

1.含有一个前端的Activity（OnResume函数被调用过了，或者说当前正在显示的那个Activity）

2.含有一个与前端Activity bind 的Service

3.含有一个调用了startForground的Service，或者该进程的Service正在调用其生命周期的函数（onCreate、onStart、onDestroy）

4.该进程含有一个BroadcastReceiver实例并且正在执行onReceive函数

Visible类进程

这类进程没有处于前端的组件，但是用户仍然能看到它们，此类进程包括两种：

1.含有一个仅onPause被调用的Activity（即它还在前台，只不过部分界面被遮住）

2.包含一个Service，并且该Service和一个Visible的Activity绑定

Service类进程： 该类进程包含一个Service，此Service通过startService启动，并且不属于前面两类进程，如MediaScannerService。

Background进程： 包含当前不可见的Activity（onStop被调用过），系统保存这些进程到一个LRU（最近最少使用）列表，当系统需要内存时，LRU里的进程将被杀死。

Empty进程： 不包含任何组件，系统保留它们仅仅是当需要的时候为了省去fork进程，创建Android运行环境等一系列漫长而艰苦的工作。

 其实Android对于进程的划分是根据oom_adj值来划分的，种类也多得多，Android是通过设置进程的oom_adj值来进行进程的调度的（kernel在OOM情况下会根据进程的oom_adj值来选择杀死一些进程）。其中Android在linux的下新增了一个LMK(low memory killer)的工作方式。LMK的职责是根据当前内存大小去杀死对应oom_adj及以上的进程以回收内存。这里就对应关键的参数，即不同内存的阈值及oom_adj。

Android平台进程调度和OOM控制的API，它们统一被封装在Process.java中，关键代码如下：

复制代码
 1 //设置线程的调度优先级
 2     public static final native void setThreadPriority(int tid, int priority)
 3             throws IllegalArgumentException, SecurityException;
 4 //设置线程的Group，实际上就是设置线程的调度策略
 5     public static final native void setThreadGroup(int tid, int group)
 6             throws IllegalArgumentException, SecurityException;
 7 //设置进程的调度策略，包括该进程的所有线程
 8     public static final native void setProcessGroup(int pid, int group)
 9             throws IllegalArgumentException, SecurityException;
10 //调整进程的oom_adj值
11     public static final native boolean setOomAdj(int pid, int amt);
复制代码
下面是ProcessList类中对oom_adj，我们可以看到Android对进程的详细分类。

复制代码
 1     // OOM adjustments for processes in various states:
 2 
 3     // Adjustment used in certain places where we don't know it yet.
 4     // (Generally this is something that is going to be cached, but we
 5     // don't know the exact value in the cached range to assign yet.)
 6     static final int UNKNOWN_ADJ = 16;
 7 
 8     // This is a process only hosting activities that are not visible,
 9     // so it can be killed without any disruption.
10     static final int CACHED_APP_MAX_ADJ = 15;
11     static final int CACHED_APP_MIN_ADJ = 9;
12 
13     // The B list of SERVICE_ADJ -- these are the old and decrepit
14     // services that aren't as shiny and interesting as the ones in the A list.
15     static final int SERVICE_B_ADJ = 8;
16 
17     // This is the process of the previous application that the user was in.
18     // This process is kept above other things, because it is very common to
19     // switch back to the previous app.  This is important both for recent
20     // task switch (toggling between the two top recent apps) as well as normal
21     // UI flow such as clicking on a URI in the e-mail app to view in the browser,
22     // and then pressing back to return to e-mail.
23     static final int PREVIOUS_APP_ADJ = 7;
24 
25     // This is a process holding the home application -- we want to try
26     // avoiding killing it, even if it would normally be in the background,
27     // because the user interacts with it so much.
28     static final int HOME_APP_ADJ = 6;
29 
30     // This is a process holding an application service -- killing it will not
31     // have much of an impact as far as the user is concerned.
32     static final int SERVICE_ADJ = 5;
33 
34     // This is a process with a heavy-weight application.  It is in the
35     // background, but we want to try to avoid killing it.  Value set in
36     // system/rootdir/init.rc on startup.
37     static final int HEAVY_WEIGHT_APP_ADJ = 4;
38 
39     // This is a process currently hosting a backup operation.  Killing it
40     // is not entirely fatal but is generally a bad idea.
41     static final int BACKUP_APP_ADJ = 3;
42 
43     // This is a process only hosting components that are perceptible to the
44     // user, and we really want to avoid killing them, but they are not
45     // immediately visible. An example is background music playback.
46     static final int PERCEPTIBLE_APP_ADJ = 2;
47 
48     // This is a process only hosting activities that are visible to the
49     // user, so we'd prefer they don't disappear.
50     static final int VISIBLE_APP_ADJ = 1;
51 
52     // This is the process running the current foreground app.  We'd really
53     // rather not kill it!
54     static final int FOREGROUND_APP_ADJ = 0;
55 
56     // This is a process that the system or a persistent process has bound to,
57     // and indicated it is important.
58     static final int PERSISTENT_SERVICE_ADJ = -11;
59 
60     // This is a system persistent process, such as telephony.  Definitely
61     // don't want to kill it, but doing so is not completely fatal.
62     static final int PERSISTENT_PROC_ADJ = -12;
63 
64     // The system process runs at the default adjustment.
65     static final int SYSTEM_ADJ = -16;
66 
67     // Special code for native processes that are not being managed by the system (so
68     // don't have an oom adj assigned by the system).
69     static final int NATIVE_ADJ = -17;
复制代码
　　　不同内存手机的阈值也被定义在ProcessList中：

复制代码
 1 //LMK设置的六个oom_adj
 2     private final int[] mOomAdj = new int[] {
 3             FOREGROUND_APP_ADJ, VISIBLE_APP_ADJ, PERCEPTIBLE_APP_ADJ,
 4             BACKUP_APP_ADJ, CACHED_APP_MIN_ADJ, CACHED_APP_MAX_ADJ
 5     };
 6     // These are the low-end OOM level limits.  This is appropriate for an
 7     // HVGA or smaller phone with less than 512MB.  Values are in KB.
 8     private final int[] mOomMinFreeLow = new int[] {
 9             12288, 18432, 24576,
10             36864, 43008, 49152
11     };
12     // These are the high-end OOM level limits.  This is appropriate for a
13     // 1280x800 or larger screen with around 1GB RAM.  Values are in KB.
14     private static final int[] mOomMinFreeHigh = new int[] {
15             73728, 92160, 110592,
16             129024, 147456, 184320
17     };
复制代码
另外在ProcessRecord中也定义了较多成员用于进程管理，就不列出来了。

下面就是AMS进程管理函数的分析了。

在AMS中，主要是两个函数来管理进程。分别为：updateLruProcessLocked 和 updateOomAdjLocked。

updateLruProcessLocked

Android所有应用进程（包括system_server）的ProcessRecord信息都保存在mPidsSelfLocked成员中，除此之外还有一个成员变量mLruProcesses也用于保存ProcessRecord。mLruProcesses的类型虽然是ArrayList，但其内部成员却是按照ProcessRecord的lruWeight大小排序的。在运行过程中，AMS会根据lruWeight的变化调整mLruProcesses成员的位置。updateLruProcessLocked的主要工作是根据app的lruWeight值调整它在数组中的位置。lruWeight越大，其在数组中的位置就越靠后。如果该app和某些Service或ContentProvider有交互关系，那就连同这些Service或ContentProvider所在进程调节lruWeight值。

updateOomAdjLocked

在updateOomAdjLocked函数中，AMS做了比较多事，都是为了最终调用computeOomAdjLocked函数计算某个进程的oom_adj和调度策略来完成对应用进程的管理，这之间4.0增加了一个接口类ComponentCallbacks2，定义了一个函数onTrimMemory，主要通知应用进程进行一定的内存释放。AMS的进程管理核心还是在computeOomAdjLocked里，computeOomAdjLocked就是一个算法，就是根据各种情况来设置几个值，这个调整的算法改进变动的可能性还是比较大的。Android在什么情况下会进行进程的调度呢？

复制代码
1 bindBackupAgent(ApplicationInfo ,int )
2 bindService(IApplicationThread,Ibinder,Intent,String,IService)
3 bringDownServiceLocked(ServiceRecord,boolean)
4 getContentProviderImpl(IApplicationThread,String)
5 publishContentProviders()
6 removeConnectionLocked()
  ...

##### PKMS
PKMS和AMS一样是Android系统的核心服务，它主要负责系统中Package的管理，应用程序的安装、卸载、信息查询等工作。PKMS也是由system_server调用PKMS的main函数启动的：

        // Start the package manager.
        Slog.i(TAG, "Package Manager");
        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,
                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);
　　PKMS的main函数代码如下：

复制代码
1     public static final PackageManagerService main(Context context, Installer installer,
2             boolean factoryTest, boolean onlyCore) {
3         //调用PKMS的构造函数，factoryTest和onlyCore都是false
4         PackageManagerService m = new PackageManagerService(context, installer,
5                 factoryTest, onlyCore);
6         //向ServiceManager中注册PKMS
7         ServiceManager.addService("package", m);
8         return m;
9     }
复制代码
　　main函数很简单，但是执行时间却很长，主要原因是PKMS在其构造函数中做了很多“体力活”，这也是Android启动速度慢的主要原因之一。其构造函数的主要功能是：
　　扫描Android系统中几个目标文件夹中的APK，从而建立合适的数据结构以管理诸如Package信息、四大组件信息、权限信息等各种信息。PKMS通过解析APK包中的AndroidManifest.xml文件，并根据其中声明的Activity标签来创建与此对应的对象并加以保管。

　　PKMS的工作流程相对简单，复杂的是其中用于保存各种信息的数据结构和它们之间的关系，以及影响最终结果的策略控制（如onlycore变量，用于判断是否只扫描系统目录）。

 一：PKMS构造函数扫描文件夹之前的准备工作

复制代码
 1         //mSdkVersion即为系统编译的SDK版本
 2         if (mSdkVersion <= 0) {
 3             Slog.w(TAG, "**** ro.build.version.sdk not set!");
 4         }
 5         
 6         mContext = context;
 7         mFactoryTest = factoryTest;//是否运行在工厂模式下
 8         mOnlyCore = onlyCore;//false为普通模式
 9         //如果此系统是eng版，则扫描Package之后，不对package做dex优化
10         mLazyDexOpt = "eng".equals(SystemProperties.get("ro.build.type"));
11         //用于存储与显示屏相关的一些属性，例如屏幕的宽、高、分辨率信息
12         mMetrics = new DisplayMetrics();
13         mSettings = new Settings(context);
14         mSettings.addSharedUserLPw("android.uid.system", //字符串
15                 Process.SYSTEM_UID,//系统进程使用的用户id，为1000
16                 ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PRIVILEGED//标志着系统Package
17         );
18         mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID,//1001
19                 ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PRIVILEGED);
20         mSettings.addSharedUserLPw("android.uid.log", LOG_UID,//1007
21                 ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PRIVILEGED);
22         mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID,//1025
23                 ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PRIVILEGED);
24         mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID,//2000
25                 ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PRIVILEGED);
26         mSettings.addSharedUserLPw("android.uid.shell", SHELL_UID,//2000
27                 ApplicationInfo.FLAG_SYSTEM|ApplicationInfo.FLAG_PRIVILEGED);
复制代码
　　刚进入构造函数，就会遇到第一个较为复杂的数据结构Setting及它的addSharedUserLPw函数，来看看addSharedUserLPw函数的代码：

复制代码
 1     SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags) {
 2         SharedUserSetting s = mSharedUsers.get(name);//mSharedUsers是一个HashMap，key为字符串，值为SharedUserSetting对象
 3         if (s != null) {
 4             if (s.userId == uid) {
 5                 return s;
 6             }
 7             PackageManagerService.reportSettingsProblem(Log.ERROR,
 8                     "Adding duplicate shared user, keeping first: " + name);
 9             return null;
10         }
11         //把key为name，值为uid的SharedUserSetting对象添加到mSharedUsers中保存
12         s = new SharedUserSetting(name, pkgFlags);
13         s.userId = uid;
14         if (addUserIdLPw(uid, s, name)) {
15             mSharedUsers.put(name, s);
16             return s;
17         }
18         return null;
19     }
复制代码
　　这一步有什么用呢？我们都看过system应用的Manifest文件标签头，举个例子：

1 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
2         package="com.android.settings"
3         coreApp="true"
4         android:sharedUserId="android.uid.system">
　　在xml中，声明了一个名为android:sharedUserId的属性，其值为“android.uid.system”，它有两个作用：

　　1.两个或多个声明了同一种android:sharedUserId的APK可以共享彼此的数据，并且可运行在同一进程中。

　　2.通过声明特定的android:sharedUserId，该APK所在进程将被赋予指定的UID，例如本例中setting声明了system的uid，运行setting的进程就可享有system用户所在对应的权限了。

　　接下来就是xml文件解析的环节啦

复制代码
 1         String separateProcesses = SystemProperties.get("debug.separate_processes");
 2         if (separateProcesses != null && separateProcesses.length() > 0) {
 3             ...
 4         } else {
 5             mDefParseFlags = 0;
 6             mSeparateProcesses = null;
 7         }
 8 
 9         mInstaller = installer;
10 
11         getDefaultDisplayMetrics(context, mMetrics);
12 
13         SystemConfig systemConfig = SystemConfig.getInstance();
14         mGlobalGids = systemConfig.getGlobalGids();
15         mSystemPermissions = systemConfig.getSystemPermissions();
16         mAvailableFeatures = systemConfig.getAvailableFeatures();
17 
18         synchronized (mInstallLock) {
19         // writer
20         synchronized (mPackages) {
21             //创建一个ThreadHander，实际就是创建了一个带消息循环处理的线程，该线程的工作就是：程序的安装和卸载等
22             mHandlerThread = new ServiceThread(TAG,
23                     Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);
24             mHandlerThread.start();
25             mHandler = new PackageHandler(mHandlerThread.getLooper());
26             Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);
27             //创建file对象指向用户的package安装包目录
28             File dataDir = Environment.getDataDirectory();
29             mAppDataDir = new File(dataDir, "data");
30             mAppInstallDir = new File(dataDir, "app");
31             mAppLib32InstallDir = new File(dataDir, "app-lib");
32             mAsecInternalPath = new File(dataDir, "app-asec").getPath();
33             mUserAppDataDir = new File(dataDir, "user");
34             mDrmAppPrivateInstallDir = new File(dataDir, "app-private");
35             //创建一个UserManager，与多用户相关，不同的用户的Package目录是不一样的
36             sUserManager = new UserManagerService(context, this,
37                     mInstallLock, mPackages);
38 
39             // Propagate permission configuration in to package manager.读取权限
40             ArrayMap<String, SystemConfig.PermissionEntry> permConfig
41                     = systemConfig.getPermissions();
42             for (int i=0; i<permConfig.size(); i++) {
43                 SystemConfig.PermissionEntry perm = permConfig.valueAt(i);
44                 BasePermission bp = mSettings.mPermissions.get(perm.name);
45                 if (bp == null) {
46                     bp = new BasePermission(perm.name, "android", BasePermission.TYPE_BUILTIN);
47                     mSettings.mPermissions.put(perm.name, bp);
48                 }
49                 if (perm.gids != null) {
50                     bp.gids = appendInts(bp.gids, perm.gids);
51                 }
52             }
53 
54             ...
55 
56             mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),
57                     mSdkVersion, mOnlyCore);
58             ...
59 
60             long startTime = SystemClock.uptimeMillis();
复制代码
　　总结就是PKMS的扫描准备工作是，扫描并解析XML 文件，并将其中的信息保存到特定的数据结构中。

二：构造函数之扫描系统Package

　　PKMS的构造函数第二阶段工作就是扫描系统中APK，由于需要逐个扫描文件，因此手机上装的程序越多，PKMS的工作量就越大，启动就越慢。

　　1.系统库的dex优化

1 // The list of "shared libraries" we have at this point is优化需要优化的jar包
2 if (dexoptRequired == DexFile.DEXOPT_NEEDED) {
3     mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet);
4 } else {
5     mInstaller.patchoat(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet);
6 }
复制代码
1             // Gross hack for now: we know this file doesn't contain any
2             // code, so don't dexopt it to avoid the resulting log spew.framework-res.apk定义了系统常用的资源，还有几个重要的Activity，如长按Power键后弹出的对话框
3             alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");
4 
5             // Gross hack for now: we know this file is only part of
6             // the boot class path for art, so don't dexopt it to
7             // avoid the resulting log spew.core-libart.jar跟ART核心有关
8             alreadyDexOpted.add(frameworkDir.getPath() + "/core-libart.jar");
复制代码
　　2.扫描系统Package

复制代码
 1             // Collected privileged system packages.
 2             final File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
 3             scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM
 4                     | PackageParser.PARSE_IS_SYSTEM_DIR
 5                     | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);
 6 
 7             // Collect ordinary system packages.
 8             final File systemAppDir = new File(Environment.getRootDirectory(), "app");
 9             scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM
10                     | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
11 
12             // Collect all vendor packages.
13             File vendorAppDir = new File("/vendor/app");
14             try {
15                 vendorAppDir = vendorAppDir.getCanonicalFile();
16             } catch (IOException e) {
17                 // failed to look up canonical path, continue with original one
18             }
19             scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM
20                     | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
复制代码
　　我们可以看到PKMS 将扫描以下几个目录：
　　　　priv-app：该目录下都是默认的系统应用，settings，contact等

　　　　vendor/app：该目录下都是厂商提供的APK文件

　　　　app：系统app

　　这一步最重要的函数是scanDirLI()，该函数会调用PackageParser对APK文件的AndroidManifest.xml文件进行解析。PackageParser完成了从物理文件到对应数据结构的转换。我们来看看该数据结构的组成：

复制代码
Package
-------
+applicationInfo:ApplicationInfo
+permission：    ArrayList<Permission>
+permissionGroups：    ArrayList<PermissionGroup>
+activities：    ArrayList<Activity>
+receivers：    ArrayList<BroadcastReceiver>
+providers：    ArrayList<Provider>
+requestedPermissions：    ArrayList<String>
+services：    ArrayList<Service>
+instrumentation：    ArrayList<Instrumentation>
+usesLibraries：    ArrayList<String>
复制代码
　　我们可以看到Android的四大组件，Permission，应用的Lib，applicationinfo等信息都已解析出来了。
　　在PackageParser扫描完一个APK之后，系统根据该APK的manifest文件创建了一个完整的Package对象，下一步就是将该Package加入到系统中，此时调用的函数是另一个scanPackageLI，主要代码如下：

复制代码
 1         if (pkg.packageName.equals("android")) {
 2             synchronized (mPackages) {
 3                 if (mAndroidApplication != null) {
 4                     ...
 5                 }
 6 
 7                 // Set up information for our fall-back user intent resolution activity.
 8                 mPlatformPackage = pkg;
 9                 pkg.mVersionCode = mSdkVersion;
10                 mAndroidApplication = pkg.applicationInfo;
11 
12                 if (!mResolverReplaced) {
13                     mResolveActivity.applicationInfo = mAndroidApplication;
14                     mResolveActivity.name = ResolverActivity.class.getName();
15                     mResolveActivity.packageName = mAndroidApplication.packageName;
16                     mResolveActivity.processName = "system:ui";
17                     mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
18                     mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;
19                     mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
20                     mResolveActivity.theme = R.style.Theme_Holo_Dialog_Alert;
21                     mResolveActivity.exported = true;
22                     mResolveActivity.enabled = true;
23                     mResolveInfo.activityInfo = mResolveActivity;
24                     mResolveInfo.priority = 0;
25                     mResolveInfo.preferredOrder = 0;
26                     mResolveInfo.match = 0;
27                     mResolveComponentName = new ComponentName(
28                             mAndroidApplication.packageName, mResolveActivity.name);
29                 }
30             }
31         }
复制代码
　　这边对Packagename为“android”的Package进行了单独的处理。和该Package对应的APK就是framework-res.apk,这个apk除了系统资源之外还负责几个Activity：

1 ChooserActivity：当多个Activity符合某个Intent时，系统弹出此Activity，由用户选择合适的应用来处理。
2 RingtonePickerActivity：铃声选择
3 ShutdownActivity：关机前弹出的选择对话框
  接下来就是对所有系统应用的处理，该段代码过于庞大，就不贴了，主要是对Package的私有财进行公有化改造。

三、扫描非系统Package

　　和系统应用扫描基本一致，不详述，主要是扫描/data/app 和 /data/app-private的目录Package。

四、扫尾工作

　　扫尾工作主要是将扫描信息再集中整理一次，比如将有些信息保存到文件中：

复制代码
 1             mSettings.mInternalSdkPlatform = mSdkVersion;
 2             //汇总并更新和Permission相关的信息
 3             updatePermissionsLPw(null, null, UPDATE_PERMISSIONS_ALL
 4                     | (regrantPermissions
 5                             ? (UPDATE_PERMISSIONS_REPLACE_PKG|UPDATE_PERMISSIONS_REPLACE_ALL)
 6                             : 0));
 7 
 8             // 将信息写到Package.xml/ package.list 及 package-stopped.xml 文件中
 9             mSettings.writeLPr();
10 
11             EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,
12                     SystemClock.uptimeMillis());
13 
14             mRequiredVerifierPackage = getRequiredVerifierLPr();

PKMS除了负责Android系统中Package安装、升级、卸载外，还有一个重要的职责，就是对外提供统一的信息查询功能，其中包括查询系统中匹配某Intent的Activity，BroadcastReceiver或Service等。

一、Activity信息的管理

前面在介绍PKMS扫描APK时提到，PKMS将解析得到的Package私有的Activity信息加入到自己的数据结构mActivities中保存。下面是相关代码：

复制代码
1             N = pkg.activities.size();//去除该APK中包含的Activity信息
2             r = null;
3             for (i=0; i<N; i++) {
4                 PackageParser.Activity a = pkg.activities.get(i);
5                 a.info.processName = fixProcessName(pkg.applicationInfo.processName,
6                         a.info.processName, pkg.applicationInfo.uid);
7                 mActivities.addActivity(a, "activity");//加入mActivities保存
复制代码
先要理解mActivities则个数据类型，mActivities为ActivityIntentResolver类型，是PKMS的成员变量，用于保存系统中所有与Activity相关的信息，它以ComponetName为key，保存PackageParser.Activity对象。由addActivity代码可以看出：

复制代码
 1         public final void addActivity(PackageParser.Activity a, String type) {
 2             final boolean systemApp = isSystemApp(a.info.applicationInfo);
 3             mActivities.put(a.getComponentName(), a);
 4             ...
 5             final int NI = a.intents.size();
 6             for (int j=0; j<NI; j++) {
 7                 //ActivityIntentInfo存储的就是xml中声明的IntentFilter信息
 8                 PackageParser.ActivityIntentInfo intent = a.intents.get(j);
 9                 if (!systemApp && intent.getPriority() > 0 && "activity".equals(type)) {
10                     intent.setPriority(0);//非系统APK的Priority必须为0
11                     Log.w(TAG, "Package " + a.info.applicationInfo.packageName + " has activity "
12                             + a.className + " with priority > 0, forcing to 0");
13                 }
14                 ...
15                 addFilter(intent);//接下来是分析这个函数，和IntentFilter有关
16             }
17         }
复制代码
addFilter代码：

复制代码
 1     public void addFilter(F f) {
 2         ...
 3         mFilters.add(f);//mFilters保存所有IntentFilter信息
 4         //除此之外，为了加快匹配工作的速度，还需要分类保存IntentFilter信息
 5         int numS = register_intent_filter(f, f.schemesIterator(),
 6                 mSchemeToFilter, "      Scheme: ");
 7         int numT = register_mime_types(f, "      Type: ");
 8         if (numS == 0 && numT == 0) {
 9             register_intent_filter(f, f.actionsIterator(),
10                     mActionToFilter, "      Action: ");
11         }
12         if (numT != 0) {
13             register_intent_filter(f, f.actionsIterator(),
14                     mTypedActionToFilter, "      TypedAction: ");
15         }
16     }
复制代码
自此所有Activity的Intent信息都已保存，下面看看Intent匹配查询
二、Intent匹配查询分析

1、客户端查询

客户端通过ApplicationPackageManager输出的queryIntentActivities函数向PKMS发起一起查询请求，代码如下：

复制代码
1         try {
2             return mPM.queryIntentActivities(
3                 intent,
4                 intent.resolveTypeIfNeeded(mContext.getContentResolver()),
5                 flags,
6                 userId);
7         }
复制代码
2、queryIntentActivities分析

复制代码
 1     @Override
 2     public List<ResolveInfo> queryIntentActivities(Intent intent,
 3             String resolvedType, int flags, int userId) {
 4         ...
 5         ComponentName comp = intent.getComponent();
 6         ...
 7         if (comp != null) {
 8             final List<ResolveInfo> list = new ArrayList<ResolveInfo>(1);
 9             final ActivityInfo ai = getActivityInfo(comp, flags, userId);
10             if (ai != null) {
11                 final ResolveInfo ri = new ResolveInfo();
12                 ri.activityInfo = ai;
13                 list.add(ri);
14             }
15             return list;
16         }
17 
18         // reader
19         synchronized (mPackages) {
20             final String pkgName = intent.getPackage();
21             if (pkgName == null) {
22                 List<CrossProfileIntentFilter> matchingFilters =
23                         getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);
24                 // Check for results that need to skip the current profile.
25                 ResolveInfo resolveInfo  = querySkipCurrentProfileIntents(matchingFilters, intent,
26                         resolvedType, flags, userId);
27                 if (resolveInfo != null) {
28                     List<ResolveInfo> result = new ArrayList<ResolveInfo>(1);
29                     result.add(resolveInfo);
30                     return result;
31                 }
32                 // Check for cross profile results.
33                 resolveInfo = queryCrossProfileIntents(
34                         matchingFilters, intent, resolvedType, flags, userId);
35 
36                 // Check for results in the current profile.
37                 List<ResolveInfo> result = mActivities.queryIntent(
38                         intent, resolvedType, flags, userId);
39                 if (resolveInfo != null) {
40                     result.add(resolveInfo);
41                     Collections.sort(result, mResolvePrioritySorter);
42                 }
43                 return result;
44             }
45             final PackageParser.Package pkg = mPackages.get(pkgName);
46             if (pkg != null) {
47                 return mActivities.queryIntentForPackage(intent, resolvedType, flags,
48                         pkg.activities, userId);
49             }
50             return new ArrayList<ResolveInfo>();
51         }
52     }
复制代码
上述代码分3种情况：

1、如果Intent指明了Component，则直接查询该Component对应的ActivityInfo。

2、如果指明了Package名，则从该Package包含的Activities中进行匹配查询。

3、若没有上述限定，则在全系统范围内进行匹配查询，就是queryIntent的工作。

 

复制代码
 1     public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly,
 2             int userId) {
 3         String scheme = intent.getScheme();
 4 
 5         ArrayList<R> finalList = new ArrayList<R>();
 6         ...
 7         F[] firstTypeCut = null;
 8         F[] secondTypeCut = null;
 9         F[] thirdTypeCut = null;
10         F[] schemeCut = null;
11 
12         // If the intent includes a MIME type, then we want to collect all of
13         // the filters that match that MIME type.
14         if (resolvedType != null) {
15             int slashpos = resolvedType.indexOf('/');
16             if (slashpos > 0) {
17                 final String baseType = resolvedType.substring(0, slashpos);
18                 if (!baseType.equals("*")) {
19                     if (resolvedType.length() != slashpos+2
20                             || resolvedType.charAt(slashpos+1) != '*') {
21                         // Not a wild card, so we can just look for all filters that
22                         // completely match or wildcards whose base type matches.
23                         firstTypeCut = mTypeToFilter.get(resolvedType);
24                         if (debug) Slog.v(TAG, "First type cut: " + Arrays.toString(firstTypeCut));
25                         secondTypeCut = mWildTypeToFilter.get(baseType);
26                         if (debug) Slog.v(TAG, "Second type cut: "
27                                 + Arrays.toString(secondTypeCut));
28                     } 
29                     ...
30             }
31         }
32 
33         // If the intent includes a data URI, then we want to collect all of
34         // the filters that match its scheme (we will further refine matches
35         // on the authority and path by directly matching each resulting filter).
36         if (scheme != null) {
37             schemeCut = mSchemeToFilter.get(scheme);
38             if (debug) Slog.v(TAG, "Scheme list: " + Arrays.toString(schemeCut));
39         }
40 
41         // If the intent does not specify any data -- either a MIME type or
42         // a URI -- then we will only be looking for matches against empty
43         // data.
44         if (resolvedType == null && scheme == null && intent.getAction() != null) {
45             firstTypeCut = mActionToFilter.get(intent.getAction());
46             if (debug) Slog.v(TAG, "Action list: " + Arrays.toString(firstTypeCut));
47         }
48         //FastImmutableArraySet是战役中特殊的数据结构，用于保存该Intent中携带的category相关信息
49         FastImmutableArraySet<String> categories = getFastIntentCategories(intent);
50         if (firstTypeCut != null) {
51             buildResolveList(intent, categories, debug, defaultOnly,
52                     resolvedType, scheme, firstTypeCut, finalList, userId);
53         }
54         if (secondTypeCut != null) {
55             buildResolveList(intent, categories, debug, defaultOnly,
56                     resolvedType, scheme, secondTypeCut, finalList, userId);
57         }
58         if (thirdTypeCut != null) {
59             buildResolveList(intent, categories, debug, defaultOnly,
60                     resolvedType, scheme, thirdTypeCut, finalList, userId);
61         }
62         if (schemeCut != null) {
63             buildResolveList(intent, categories, debug, defaultOnly,
64                     resolvedType, scheme, schemeCut, finalList, userId);
65         }
66         sortResults(finalList);//将匹配结果按priority大小排序
67         ...
68         return finalList;
69     }
复制代码
 queryIntentActivities功能简单粗暴，数据结构较多，目的性强，不难分析  


##### 类型转换

数组转成list  1.
String[] userid = {"aa","bb","cc"};

List<String> userList = new ArrayList<String>();

Collections.addAll(userList, userid);

数组转成list  2.
String[] userid = {"aa","bb","cc"};

List<String> userList = Arrays.asList(userid);

另：Arrays.asList()返回一个受指定数组支持的固定大小的列表。所以不能做Add、Remove等操作。

List list = new ArrayList(Arrays.asList(userid));这样操作就可以了。


数组转成list  3.
String[] userid = {"aa","bb","cc"};

List<String> userList = new ArrayList<String>(userid.length);

for(String uid: userid){

userList.add(uid);

}

list转数组 1.
List<String> strList = new ArrayList<String>();

strList.add("aa");

strList.add("bb");

Object[] objs = strList.toArray();
如果要变成String数组，需要强转类型。

String[] strs = (String[]) strList.toArray(new String[0]);
也可以指定大小：

String[] strs = strList.toArray(new String[strList.size()]);

list转数组 2.

List<String> strList = new ArrayList<String>();

strList.add("aa");

strList.add("bb");

String[] strs = new String[strList.size()]; 

##### 问题

> 错误: 类型的格式不正确, 给出了原始类型的类型参数
```bash
public abstract class BaseReusePagerAdapter<VH extends BaseReusePagerAdapter.Holder> extends PagerAdapter {
    public abstract class Holder<T> {
        public T item;
        public View itemView;
        public int position;
        public int viewType;

        public Holder(View itemView) {
            this.itemView = itemView;
        }

        public abstract void updateWithItem(T model);
    }
}

public class MusicAlbumBgHolder extends BaseReusePagerAdapter.Holder<IMusicBg> {

}

使用IMusicBg报错，type arguments give on a raw type 
错误: 类型的格式不正确, 给出了原始类型的类型参数

修改：
public abstract class Holder<T>
public static abstract class Holder<T>
```

> Error: pg_config executable not found
```bash
brew install postgresql
echo 'export PATH="postgresql_path/bin:$PATH"' >> ~/.bash_profile
```

> Gradle sync failed: Timeout waiting to lock buildscript class cache for build file '/Users/user/Documents/android-studio-pubble/App/build.gradle' (/Users/user/.gradle/caches/2.2.1/scripts/build_bqh4uod6cat7u5cm5qkoye2ky/ProjectScript/buildscript). It is currently in use by another Gradle instance.
         Owner PID: unknown
         Our PID: 909
         Owner Operation: unknown
         Our operation: Initialize cache
         Lock file: /Users/user/.gradle/caches/2.2.1/scripts/build_bqh4uod6cat7u5cm5qkoye2ky/ProjectScript/buildscript/cache.properties.lock
         Consult IDE log for more details (Help | Show Log)
```bash
解决方案：
find ~/.gradle -type f -name "*.lock" | while read f; do rm $f; done

./gradlew clean
以下方案不一定管用
删除缓存lock文件

gradle --stop
关闭所有 gradle 进程

cache 和 native 会一直有 lock 文件
终极解决方案：rm -rf ~/.gradle/

C:\Users\Administrator\.gradle\caches
~/.gradle/caches
```

> Split lib_slice_5_apk 无法安装
Application Installation Failed

Installation failed with message Failed to finalize session : INSTALL_FAILED_INVALID_APK: Split lib_slice_5_apk was defined multiple times.
It is possible that this issue is resolved by uninstalling an existing version of the apk if it is present, and then re-installing.

WARNING: Uninstalling will remove the application data!

Do you want to uninstall the existing application?

解决方法
Android studio  -> preferences ->  build,execution... -> instant run (取消取消Instant Run)不要选中


> Android Studio打开出现Unknown run configuration type AndroidRunConfigurationType
进入File->Settings->Plugins->然后把Android Support后面的按钮勾选上，点击Apply，运气好的话会直接出现提示重启的按钮，点击后重新启动Android studio ，问题就解决了。

 运气不好的话点击完Apply后会出现如下的错误提示

unable to apply changes:plugins "App links assistant",firebase services won'...

此时你需要把Android Support的同级目录下的红色字体后面的框的选中取消，点击Apply后，关掉此页面。重复之前的步骤File->Settings->Plugins->在把Android Support后面的按钮勾选上，然后点击Apply。

> Write access is allowed from event dispatch thread only
File->project structure->Android sdk -> embedded

解决方法：
给当前的android studio的jdk换个版本，使用android studio 自带的jre。JDK版本 和 sdk版本冲突。


> No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android
用不到ndk就卸载

或者换低版本ndk r16
https://developer.android.com/ndk/downloads/?hl=zh-cn

> Error running 'app': Unknown run configuration type AndroidRunConfigurationType
解决方法：打开初始小窗口界面 -》Plugins   把右侧没有勾选的插件选上，点击Apply—》OK 即可

> build 卡在 app_debugCompile
网络问题：重新配置资源库

buildscript {
    repositories {
        maven { url 'https://dl.bintray.com/umsdk/release' }
        maven {
            url 'https://maven.google.com'
        }
//        maven {url 'http://developer.huawei.com/repo/'}
      
        maven {
            url 'http://maven.aliyun.com/nexus/content/groups/public/'
        }

        maven {
            url 'https://jcenter.bintray.com/'
        }
        maven {
            url "http://storage.googleapis.com/r8-releases/raw/master"
        }
        maven {
            url "http://maven.oschina.net/content/groups/public/"
        }
        maven {
            url 'https://maven.aliyun.com/repository/apache-snapshots'
        }

        mavenCentral()
        jcenter()
        google()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.1.3'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        maven { url 'https://dl.bintray.com/umsdk/release' }
        maven {url 'http://developer.huawei.com/repo/'}

        maven {
            url 'http://maven.aliyun.com/nexus/content/groups/public/'
        }
        maven {
            url 'https://maven.google.com/'
            name 'Google'
        }

        maven {
            url 'https://jcenter.bintray.com/'
        }
        maven {
            url "http://maven.oschina.net/content/groups/public/"
        }
        maven {
            url 'https://maven.aliyun.com/repository/apache-snapshots'
        }

        maven { url "https://jitpack.io" }
        maven { url "https://dl.bintray.com/thelasterstar/maven/" }//新浪微博SDK
        maven {
            url "http://storage.googleapis.com/r8-releases/raw/master"
        }
        jcenter()
        google()
    }
}

> as错误检查
工程目录下将gradlew 可执行文件 chmod +x gradlew
gradlew compileDebugSources --stacktrace -info
mac下
./gradlew compileDebugSources --stacktrace -info

Manifest merger failed with multiple errors终极解决办法
./gradlew processReleaseManifest --stacktrace

> ida pro mac 密码
ida 动态链接库so文件 反编译工具
qY2jts9hEJGy

> jd-gui mac下不能使用，闪退
brew cask install jd-gui

> Android性能优化典范
http://hukai.me/android-performance-patterns/ 
https://www.cnblogs.com/simbachen/p/4462885.html

> AVD启动黑屏 Guest isn't online after 7 seconds
Android studio 工具栏 avd manager 修改使用cloud 启动 放弃quick 启动

> DELETE_FAILED_INTERNAL_ERROR
http://www.cnblogs.com/huangenai/p/6839477.html 
Android Studio > Settings> Build, Execution, Deployment > Instant Run > Uncheck : Enable Instant Run



> app时提示Please select Android SDK
https://blog.csdn.net/wilschan0201/article/details/73251285


> “Installation failed with message INSTALL_FAILED_TEST_ONLY
https://blog.csdn.net/Johnny2017/article/details/79480535

> android studio报错Jack is required to support java 8

```bash
Error:Jack is required to support java 8 language features. Either enable Jack or remove sourceCompatibility JavaVersion.VERSION_1_8.


原因：
AS新版本java8新特性需要jack工具链
新的 Java 8 语言功能，还需使用新的 Jack 工具链。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。

以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：

旧版 javac 工具链： 
javac (.java –> .class) –> dx (.class –> .dex) 
新版 Jack 工具链： 
Jack (.java –> .jack –> .dex)

官方说明网址：https://developer.android.com/preview/j8-jack.html

defaultConfig {
        ...
        jackOptions {
            enabled true
        }//加了这句话就好了
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
```


> android studio报错More than one file was found with OS independent path 'META-INF/xxxx'
android {

      packagingOptions {
        exclude 'META-INF/xxxxx'
        //添加点击事件

      }
}

> android studio报错Manifest merger failed with multiple errors
辅助工具栏（屏幕左下方找到build）查看日志。根据日志提示修改

> android studio 运行项目不报错，一直卡在gradle build running
project的build.gradle版本
与app module使用的built tool verserion不对应导致了gradle失败（升级gradle版本或者bool tool version另一个也要一起修改）



> AVD启动报错，无法启动
tools => avd manager  => actions => cold boot now
avd变卡了也可以用cold boot now 清除缓存

> android studio误删文件恢复
右键点击工程-->local history-->show history 即可找回文件。recovey

> Duplicate files copied in APK META-INF/LICENSE
```bash
    // Duplicate files copied in APK META-INF/LICENSE
    // File1: /Users/xiaoyu/Public/android/ChatPaint/library/ddp/libs/jackson-mapper-asl-1.9.7.jar
    // File2: /Users/xiaoyu/Public/android/ChatPaint/library/ddp/libs/jackson-core-asl-1.9.7.jar


    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/ASL2.0'
    }
```

> android studio gradle版本对应
https://developer.android.com/studio/releases/gradle-plugin

Plugin version  Required Gradle version
1.0.0 - 1.1.3 2.2.1 - 2.3
1.2.0 - 1.3.1 2.2.1 - 2.9
1.5.0 2.2.1 - 2.13
2.0.0 - 2.1.2 2.10 - 2.13
2.1.3 - 2.2.3 2.14.1+
2.3.0+  3.3+
3.0.0+  4.1+
3.1.0+  4.4+

// The google() repo is a shortcut to looks in Google's Maven repository for dependencies. It was introduced with gradle v.4.0.
// In any case (also with Android Studio 2.3, gradle plugin 2.3.3 and gradle v3.3) you can use the same maven repo using { url 'https://maven.google.com'}


##### 36中设计模式

```bash
1. 观察者模式
实现方法1.（Observer, Observable, Monitor）

实现方法2. EventBus（发布/订阅模式）
package com.net.framework;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.telephony.TelephonyManager;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.Enumeration;

/**
 * Author   Shone
 * Date     04/07/16.
 * Github   https://github.com/shonegg
 */
public class Network {

    public enum Type {
        UNKNOWN, WIFI, MOBILE, MOBILE2G, MOBILE3G, MOBILE4G
    }

    public static NetworkInfo getCurrentActiveNetwork(Context context) {
        try {
            ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            if (connectivity != null) {
                return connectivity.getActiveNetworkInfo();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String getIPAddress() {
        try {
            Enumeration<NetworkInterface> netWorkInterface = NetworkInterface.getNetworkInterfaces();
            while (netWorkInterface.hasMoreElements()) {
                Enumeration<InetAddress> address = netWorkInterface.nextElement().getInetAddresses();
                while (address.hasMoreElements()) {
                    InetAddress inetAddr = address.nextElement();
                    if (!inetAddr.isLoopbackAddress()) {
                        if (inetAddr instanceof Inet4Address) {
                            return inetAddr.getHostAddress().toString();
                        }
                    }
                }
            }
        } catch (SocketException e) {
            e.printStackTrace();
        }
        return "0.0.0.0";
    }

    /**
     * 得到当前的手机网络类型
     * @param context
     * @return
     */
    public static Type getSubType(Context context) {
        NetworkInfo netWorkInfo = Network.getCurrentActiveNetwork(context);
        if (netWorkInfo != null && netWorkInfo.getType() == ConnectivityManager.TYPE_MOBILE) {
            switch (netWorkInfo.getSubtype()) {
                case TelephonyManager.NETWORK_TYPE_GPRS://GPRS （联通2g）
                case TelephonyManager.NETWORK_TYPE_EDGE://EDGE（移动2g）
                case TelephonyManager.NETWORK_TYPE_CDMA: {// CDMA （电信2g）
                    return Type.MOBILE2G;//2G网络
                }
                case TelephonyManager.NETWORK_TYPE_UMTS://UMTS（联通3g）
                case TelephonyManager.NETWORK_TYPE_HSDPA://HSDPA（联通3g）
                case TelephonyManager.NETWORK_TYPE_EVDO_B://EVDO  版本B（电信3g）
                case TelephonyManager.NETWORK_TYPE_EVDO_0://EVDO  版本0.（电信3g）
                case TelephonyManager.NETWORK_TYPE_EVDO_A: {//EVDO   版本A （电信3g）
                    return Type.MOBILE3G;//3G网络
                }
                case TelephonyManager.NETWORK_TYPE_LTE:{
                    return Type.MOBILE4G;//4G网络
                }
            }
            return Type.MOBILE;//未知的移动网络
        } else if (netWorkInfo != null && netWorkInfo.getType() == ConnectivityManager.TYPE_WIFI){
            return Type.WIFI;
        }
        return Type.UNKNOWN;//未知网络
    }

    public static String getSubTypeName(Context context) {
        NetworkInfo netWorkInfo = getCurrentActiveNetwork(context);
        return netWorkInfo != null ? netWorkInfo.getSubtypeName() : null;
    }

    public static Type getType(Context context) {
        NetworkInfo netWork = getCurrentActiveNetwork(context);
        if (netWork != null) {
            switch (netWork.getType()) {
                case ConnectivityManager.TYPE_MOBILE: {
                    return Type.MOBILE;
                }
                case ConnectivityManager.TYPE_WIFI: {
                    return Type.WIFI;
                }
            }
        }
        return Type.UNKNOWN;
    }

    public static String getTypeName(Context context) {
        NetworkInfo net = Network.getCurrentActiveNetwork(context);
        return net != null ? net.getTypeName() : null;
    }

    /**
     * 网络是否可用
     *
     * @param context
     * @return
     */
    public static boolean isAvailable(Context context) {
        NetworkInfo net = Network.getCurrentActiveNetwork(context);
        return net != null && net.isAvailable();
    }

    /**
     * 网络是否连接
     *
     * @param context
     * @return
     */
    public static boolean isConnected(Context context) {
        NetworkInfo net = Network.getCurrentActiveNetwork(context);
        return net != null && net.isConnected();
    }
}


package com.net.framework;

import android.content.Context;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;

@Deprecated
public class NetworkUtils {

    /**
     * 判断是不是wifi网络状态
     *
     * @param context
     * @return
     */
    public static boolean isWifi(Context context) {
        return "2".equals(getNetType(context)[0]);
    }

    /**
     * 判断是不是2/3G网络状态
     *
     * @param context
     * @return
     */
    public static boolean isMobile(Context context) {
        return "1".equals(getNetType(context)[0]);
    }

    /**
     * 网络是否可用
     *
     * @param context
     * @return
     */
    public static boolean isNetAvailable(Context context) {
        if ("1".equals(getNetType(context)[0]) || "2".equals(getNetType(context)[0])) {
            return true;
        }
        return false;
    }

    /**
     * 获取当前网络状态 返回2代表wifi,1代表2G/3G
     *
     * @param context
     * @return
     */
    private static String[] getNetType(Context context) {
        String[] result = {"Unknown", "Unknown"};
        PackageManager pm = context.getPackageManager();
        if (pm.checkPermission("android.permission.ACCESS_NETWORK_STATE",
                context.getPackageName()) != PackageManager.PERMISSION_GRANTED) {
            result[0] = "Unknown";
            return result;
        }

        ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (connectivityManager == null) {
            result[0] = "Unknown";
            return result;
        }

        NetworkInfo networkInfo1 = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);//1
        if (networkInfo1 != null && networkInfo1.getState() == NetworkInfo.State.CONNECTED) {
            result[0] = "2";
            return result;
        }

        NetworkInfo networkInfo2 = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);//0
        if (networkInfo2 != null && networkInfo2.getState() == NetworkInfo.State.CONNECTED) {
            result[0] = "1";
            result[1] = networkInfo2.getSubtypeName();
            return result;
        }

        return result;
    }
}

package com.net.framework;

/**
 * Author   Shone
 * Date     04/07/16.
 * Github   https://github.com/shonegg
 */

import java.util.Observable;
import java.util.Observer;

public abstract class NetObserver implements Observer {
    public static class NetAction {
        private boolean isAvailable;
        private boolean isWifi;
        private Network.Type type;

        public NetAction(boolean isAvailable, boolean isWifi, Network.Type type) {
            super();
            this.isAvailable = isAvailable;
            this.isWifi = isWifi;
            this.type = type;
        }

        public boolean isAvailable() {
            return this.isAvailable;
        }

        public Network.Type getType() {
            return type;
        }

        public void setType(Network.Type type) {
            this.type = type;
        }

        public boolean isWifi() {
            return this.isWifi;
        }
    }

    public abstract void notify(NetAction action);

    @Override
    public void update(Observable observable, Object data) {
        this.notify(((NetAction) data));
    }
}

package com.net.framework;

/**
 * Author   Shone
 * Date     04/07/16.
 * Github   https://github.com/shonegg
 */

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;

import java.util.Observable;
import java.util.Observer;

public class NetObservable extends Observable {
    private Context context;

    public NetObservable(Context context) {
        super();
        this.context = context;
    }

    @Override
    public void addObserver(Observer observer) {
        try {
            super.addObserver(observer);
            NetworkInfo networkInfo = Network.getCurrentActiveNetwork(this.context);
            if (networkInfo != null) {
                if (!networkInfo.isAvailable()) {
                    observer.update(this, new NetObserver.NetAction(false, false, Network.getSubType(context)));
                    return;
                }

                if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) {
                    observer.update(this, new NetObserver.NetAction(true, true, Network.getSubType(context)));
                    return;
                }

                observer.update(this, new NetObserver.NetAction(true, false, Network.getSubType(context)));
                return;
            }

            observer.update(this, new NetObserver.NetAction(false, false, Network.getSubType(context)));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void notifyObservers(Object data) {
        try {
            this.setChanged();
            super.notifyObservers(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

package com.net.framework;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;

public class NetMonitor extends BroadcastReceiver {
    private static final String TAG = "NetMonitor";
    private static NetMonitor instance;
    private NetObservable observable;


    public void addObserver(NetObserver observer) {
        this.observable.addObserver(observer);
    }

    public void delObserver(NetObserver observer) {
        this.observable.deleteObserver(observer);
    }

    public void destory() {
        this.observable.deleteObservers();
    }

    public static NetMonitor getInstance() {
        if (instance == null) {
            synchronized (NetMonitor.class) {
                if (instance == null) {
                    instance = new NetMonitor();
                }
            }
        }
        return instance;
    }

    public void init(Context context) {
        this.observable = new NetObservable(context);
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        context.registerReceiver(this, intentFilter);
    }

    private void notifyNetState(Context context) {
        try {
            NetworkInfo networkInfo = Network.getCurrentActiveNetwork(context);
            if (networkInfo != null) {
                if (!networkInfo.isAvailable()) {
                    this.observable.notifyObservers(new NetObserver.NetAction(false, false, Network.getSubType(context)));
                    return;
                }
                if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) {
                    this.observable.notifyObservers(new NetObserver.NetAction(true, true, Network.getSubType(context)));
                    return;
                }

                this.observable.notifyObservers(new NetObserver.NetAction(true, false, Network.getSubType(context)));
                return;
            }

            this.observable.notifyObservers(new NetObserver.NetAction(false, false, Network.getSubType(context)));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        this.notifyNetState(context);
    }
}

package com.net.framework;

import android.app.Application;

/**
 * Author   Shone
 * Date     23/07/16.
 * Github   https://github.com/shonegg
 */
public class NetApplication extends Application {


    @Override
    public void onCreate() {
        super.onCreate();
        NetMonitor.getInstance().init(this);
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        System.gc();
    }

    @Override
    public void onTerminate() {
        super.onTerminate();
        NetMonitor.getInstance().destory();
    }

}

任务：Activity需要监听网络状态
private NetObserver mNetObserver = new NetObserver() {
    @Override
    public void notify(NetAction action) {
        if (action.isAvailable()) {
        } else {
        }
    }
};
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    this.mContext = this;
    NetMonitor.getInstance().addObserver(this.mNetObserver);
}


@Override
protected void onDestroy() {
    super.onDestroy();
    NetMonitor.getInstance().delObserver(this.mNetObserver);
}



实现3.
import java.util.ArrayList;

import java.util.List;

  

  

public class MyOberver {

        public static void main(String[] args) {

               American american=new American();

               Chinese chinese=new Chinese();

               Iphone iphone=new Iphone();

               System.out.println("一个美国人登记购买");

               iphone.register(american);

               System.out.println("一个中国人登记购买");

               iphone.register(chinese);

               try {

                      System.out.println("经过6个月的漫长等待...");

                     Thread.sleep(2000);

              } catch (InterruptedException e) {

                     // TODO Auto-generated catch block

                     e.printStackTrace();

              }

               iphone.notifys();

       }

}

/**观察者*/

class Iphone{

       private List<Fensi> list=new ArrayList<Fensi>();

       public void register(Fensi n){

              list.add(n);

              System.out.println("又一个苹果被预订了,现在总共有："+list.size()+"个人预订了...");

       }

       public void notifys(){

              System.out.println("IPHONE 6现在高调发售...");

              for (Fensi n:list) {

                            n.receive();

              }

       }

}

class American implements Fensi{

       @Override

       public void receive() {

              // TODO Auto-generated method stub

              System.out.println("美国人喊叫：嗯哼，有点贵....");

       }

}

class  Chinese implements Fensi{

       @Override

       public void receive() {

              // TODO Auto-generated method stub

              System.out.println("中国人：我终于买到了，高兴死了....");

       }

}

interface Fensi{

              public void receive();

}

2.工厂模式

public class test {

       public static void main(String[] args) {

              Location position= new LocationFactory().getInstance("xiaomi");

              position.getPosition();

              position.getCityName(10, 20);

       }

}

  

class LocationFactory{

       public static Location getInstance(String type){

              if("baidu".equals(type)){

                     return new BaiduLocation();

              }else {

                     return new XiaoMiLocation();

              }

       }

}

class BaiduLocation implements Location{

       @Override

       public void getPosition() {

              // TODO Auto-generated method stub

              System.out.println("通过百度定位获取到当前的经纬度是XXXXX");

       }

       @Override

       public void getCityName(long lat, long lng) {

              // TODO Auto-generated method stub

              System.out.println("通过百度定位获取到当前的城市是XXXXX");

       }

}

class XiaoMiLocation implements Location{

       @Override

       public void getPosition() {

              // TODO Auto-generated method stub

              System.out.println("通过小米定位获取到当前的经纬度是XXXXX");

       }

       @Override

       public void getCityName(long lat, long lng) {

              // TODO Auto-generated method stub

              System.out.println("通过小米定位获取到当前的城市是XXXXX");

       }

}

interface Location{

       public void getPosition();

       public void getCityName(long lat,long lng);

}


3. 单例模式

public class Room {

       public static Room key;

       public static void main(String[] args) {

              Room room=getKey();

              room.openDoor();

              Room room1=getKey();

              room1.openDoor(); 

       }

       public static Room getKey(){

              if(key==null){

                     key=new Room();

              }

              return key;

       } 

       public void openDoor(){

              System.out.println("我打开了门......");

       }

}
```



##### DataSupport
```bash
public final class SQLiteDatabase extends SQLiteClosable {
    public static final int CONFLICT_ABORT = 2;
    public static final int CONFLICT_FAIL = 3;
    public static final int CONFLICT_IGNORE = 4;
    public static final int CONFLICT_NONE = 0;
    public static final int CONFLICT_REPLACE = 5;
    public static final int CONFLICT_ROLLBACK = 1;
    public static final int CREATE_IF_NECESSARY = 268435456;
    public static final int ENABLE_WRITE_AHEAD_LOGGING = 536870912;
    public static final int MAX_SQL_CACHE_SIZE = 100;
    public static final int NO_LOCALIZED_COLLATORS = 16;
    public static final int OPEN_READONLY = 1;
    public static final int OPEN_READWRITE = 0;
    public static final int SQLITE_MAX_LIKE_PATTERN_LENGTH = 50000;

    SQLiteDatabase() {
        throw new RuntimeException("Stub!");
    }

    protected void finalize() throws Throwable {
        throw new RuntimeException("Stub!");
        //这样定义的方法，表示在程序执行的时候，实际由android rom里面相同的类来执行。
    }
}
```
##### LitePal
```bash
org.litepal.android:core:1.5.0



查询：
List<Friend> Friends = DataSupport.where("userid != ?", UserCache.getId()).find(Friend.class);
DataSupport.findAll(Groups.class)
.order("update desc")
.limit(10)

修改：
DataSupport.updateAll(GroupMember.class, values, "userid = ?", userId)

保存：
DataSupport.saveAll(friends);

删除：
DataSupport.deleteAll(Friend.class, "userid = ?", friendId);
DataSupport.deleteAll(GroupMember.class, "groupid = ? and userid = ?", groupId, userId);
DataSupport.deleteAll(Groups.class)

upsert:
friend.saveOrUpdate("userid = ?", friend.getUserId());

public class Subscription extends DataSupport implements Serializable {}

app/src/main/assets目录下添加litepal.xml

<?xml version="1.0" encoding="utf-8"?>
<litepal>
<dbname value="caoliao_chatpaint"></dbname>

<version value="1"></version>

<list>
    <mapping class="cn.net.caoliao.chatpaint.db.model.Friend"></mapping>
    <mapping class="cn.net.caoliao.chatpaint.db.model.Subscription"></mapping>
    <mapping class="cn.net.caoliao.chatpaint.db.model.Groups"></mapping>
    <mapping class="cn.net.caoliao.chatpaint.db.model.GroupMember"></mapping>
</list>
</litepal>

3.0版本使用

public class MyOwnApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        LitePal.initialize(this);
    }
    ...
}

public class Album extends LitePalSupport {
}

List<Song> allSongs = LitePal.findAll(Song.class);

implementation 'org.litepal.android:java:3.0.0'
```

##### Glide
```bash
com.github.bumptech.glide:compiler:4.8.0
https://muyangmin.github.io/glide-docs-cn/


3.7使用方法
// 不支持svg gif
Glide.with(mContext).load(mUserInfo.getPortraitUri()).centerCrop().into(getView().getIvHeader());

4.8使用方法
// GlideType - 添加对新的资源类型的支持(GIF，SVG 等等)

// Min Sdk Version - 使用 Glide 需要 min SDK 版本 API 14 (Ice Cream Sandwich) 或更高。

// Compile Sdk Version - Glide 必须使用 API 27 (Oreo MR1) 或更高版本的 SDK 来编译。

// Support Library Version - Glide 使用的支持库版本为 27。

```

##### 七牛
```bash
com.qiniu:qiniu-android-sdk
github: https://github.com/qiniu/android-sdk

import com.qiniu.android.storage.UploadManager;
mUploadManager.put(imageFile, null, token, (s, responseInfo, jsonObject) -> {
    LogUtils.e("response " + responseInfo.isOK());
    if (responseInfo.isOK()) {
        String key = jsonObject.optString("key");
        String imageUrl = "http://" + domain + "/" + key;
        //修改自己服务器头像数据
        ApiRetrofit.getInstance().setPortrait(imageUrl)
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(setPortraitResponse -> {
                    if (setPortraitResponse != null && setPortraitResponse.getCode() == 200) {
                        Friend friend = DBManager.getInstance().getFriendById(UserCache.getId());
                        if (friend != null) {
                            friend.setPortraitUri(imageUrl);
                            DBManager.getInstance().saveOrUpdateFriend(friend);
                            DBManager.getInstance().updateGroupMemberPortraitUri(UserCache.getId(), imageUrl);
                            Glide.with(mContext).load(friend.getPortraitUri()).centerCrop().into(getView().getIvHeader());
                            BroadcastManager.getInstance(mContext).sendBroadcast(AppConst.CHANGE_INFO_FOR_ME);
                            BroadcastManager.getInstance(mContext).sendBroadcast(AppConst.UPDATE_CONVERSATIONS);
                            BroadcastManager.getInstance(mContext).sendBroadcast(AppConst.UPDATE_GROUP);
                            UIUtils.showToast(UIUtils.getString(cn.net.caoliao.chatpaint.R.string.set_success));
                        }
                        mContext.hideWaitingDialog();
                    } else {
                        uploadError(null);
                    }
                }, this::uploadError);
    } else {
        uploadError(null);
    }
}, null);
```

##### eventbus
```bash
org.greenrobot:eventbus
compile 'org.greenrobot:eventbus:3.0.0'
repositories {
    mavenCentral()
}


定义消息类
public class MessageEvent {
    public int pos;
    public String cityId;
    public MessageEvent(int pos , String cityId) {
        this.pos = pos;//用于标记是发给哪个接收者的，如果同一个消息有多个接收者
        this.cityId = cityId;
    }
}
编写发送消息的代码
EventBus.getDefault().post(new MessageEvent(1,“id”);

编写接收者部分(接收者和发送者都可以是任意线程，任意activity，fragment
// 当MessageEvent被当做参数发送的时候这个方法将会被触发.
@Subscribe(threadMode = ThreadMode.MAIN) //表示消息接收函数运行在ui线程，即可以直接操作界面显示
public void onMessageEvent(MainActivity.MessageEvent event) {
    //Toast.makeText(getActivity(), "from fragment: "+event.pos, Toast.LENGTH_SHORT).show();
    if (indexOfFragment == event.pos) { // the current page is been selected//当有多个接收者用编号区分是否发给自己的消息
        System.out.println("the current page is been selected page is "+ event.pos);
        //only do this on current page
        //todo send update ui msg

    }
}

注册接受者
@Override
public void onPause() {
    super.onPause();
    EventBus.getDefault().unregister(this);
    System.out.println("fragment ::::: un register"+this);

}

@Override
public void onResume() {
    super.onResume();
    EventBus.getDefault().register(this);
    System.out.println("fragment ::::: register address:" + this);
}

// 注意不要在onStart和onStop里面做，具体原因没有分析，但是使用onStart和onStop在使用时会出现，接收到消息，ui不更新的现象（接收者在fragment里面）
```

##### ddp
```bash
https://github.com/delight-im/Android-DDP
// 适合单独链接（有heartbeat长链接）websocket使用的是com.neovisionaries.ws.client.WebSocket
// mWebSocket = new WebSocketFactory().setConnectionTimeout(30000).createSocket(mServerUri);
public class MyActivity extends Activity implements MeteorCallback {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // ...

        // create a new instance
        mMeteor = new Meteor(this, "ws://example.meteor.com/websocket");

        // register the callback that will handle events and receive messages
        mMeteor.addCallback(this);

        // establish the connection
        mMeteor.connect();
    }
}



String subscriptionId = mMeteor.subscribe("stdout");

mMeteor.unsubscribe(subscriptionId);


final Map<String, Object> data = new HashMap<String, Object>();
data.put("region", "86");
data.put("phone", "17098901501");

mMeteor.call("checkPhoneAvailable", new Object[] { data }, new ResultListener() {

    @Override
    public void onSuccess(String result) {
        LogUtils.e("checkPhoneAvailable succes " + result);
    }

    @Override
    public void onError(String error, String reason, String details) {
        LogUtils.e("checkPhoneAvailable error " + reason);
    }

});


https://github.com/kutrumbo/java-ddp-client
// 使用了Observr，可以单独写在一个class中，websocket使用的是org.java_websocket.client.WebSocketClient
// this.wsClient = new WebSocketClient(new URI(meteorServerAddress)) {
//     @Override
//     public void onOpen(ServerHandshake handshakedata) {
//         connectionOpened();
//     }
    
//     @Override
//     public void onMessage(String message) {
//         received(message);
//     }
    
//     @Override
//     public void onError(Exception ex) {
//         handleError(ex);
//     }
    
//     @Override
//     public void onClose(int code, String reason, boolean remote) {
//         connectionClosed(code, reason, remote);
//     }
// }
try {
    
    // create DDP client instance
    DdpClient ddp = new DdpClient(meteorIp, meteorPort);
    
    // create DDP client observer
    Observer obs = new SimpleDdpClientObserver();
    
    // add observer
    ddp.addObserver(obs);
                
    // make connection to Meteor server
    ddp.connect();
    
    Thread.sleep(1000);
    
    ddp.subscribe("allPositions", new Object[]{});
            
} catch (URISyntaxException e) {
    e.printStackTrace();
} catch (InterruptedException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}

https://github.com/kenyee/android-ddp-client
// 使用了java-ddp-client，是二次封装
```

##### EncryptUtils
```bash
cn.net.caoliao.chatpaint.util:EncryptUtils
byte[] bts = MessageDigest.getInstance("SHA-256").update("password".getBytes("UTF-8"));
for (int i = 0; i < bts.length; i++) {
    tmp = (Integer.toHexString(bts[i] & 0xFF));
    if (tmp.length() == 1) {
        des += "0";
    }
    des += tmp;
}
```

##### 手机IMEI，IMSI，ICCID
```bash
需要权限：
<uses-permission android:name="android.permission.READ_PHONE_STATE" />


读取内容：
TelephonyManager telephonyManager = (TelephonyManager) this.getSystemService(TELEPHONY_SERVICE);// 取得相关系统服务

String simOperatorName = telephonyManager.getSimOperatorName();//运行商名字
String imei = telephonyManager.getDeviceId();       //取出 IMEI
String imeiAPI26 = telephonyManager.getImei();       //取出 IMEI 需要 api26以上
String tel = telephonyManager.getLine1Number();     //取出 MSISDN，很可能为空
String imsi = telephonyManager.getSubscriberId();     //取出 IMSI
String icc = telephonyManager.getSimSerialNumber();  //取出 ICCID
```

##### getDrawable
```bash
老版本：getResources().getDrawble(R.drawable.xxx);
新版本：ContextCompat.getDrawble(mContext, R.drawable.xxx);
代码实现：mContext.getResources().getIdentifier("country_"+item.getIso().toLowerCase(),"drawable", mContext.getPackageName())
```

##### loftimageview
图片加载(图片加载的时候显示加载进度)[图片加载的时候显示加载进度]
https://github.com/ChengangFeng/LofterImageView
进度条（背景 + 进度 + 百分比数字） + 图片缩放 + 多图预览
Step 1 ：
获取自定义配置initAttrs()、初始化画笔initProSettings()
public LofterProgressView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    //先获取自定义的配置
    initAttrs(context, attrs);
    //再进行初始化相关的配置
    initProSettings();
}
Step 2 ：（绘制圆角矩形背景）
mBgWidth = typedArray.getDimensionPixelSize(R.styleable.ProgressView_bgWidth, 100);
mBgColor = typedArray.getColor(R.styleable.ProgressView_bgColor, Color.WHITE);
mBgCornerRadius = typedArray.getDimensionPixelSize(R.styleable.ProgressView_bgCornerRadius, 20);

mBgPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
mBgPaint.setColor(  );
mBgPaint.setStyle(Paint.Style.FILL);
// 画矩形了，但是前提是要清楚矩形具体要画在哪里，也就是说要知道坐标的位置
// onDraw()和onMeasure()中都不建议创建对象，因此我们在这个控件中创建mBgRect的成员变量，并在initProSettings()方法中将这个创建RectF对象并赋给mBgRect

mBgRect = new RectF();
// 而在onMeasure()中，我们只要设置一下矩形的坐标即可

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    //中心的位置
    centerX = getMeasuredWidth() / 2;
    centerY = getMeasuredHeight() / 2;

    //计算并设置好bg圆角矩形的位置
    mBgRect.set(centerX - (mBgWidth / 2), centerY - (mBgWidth / 2), centerX + (mBgWidth / 2), centerY + (mBgWidth / 2));
    ...
}
// 最后，在onDraw()中使用drawRoundRect(),传入设置好坐标的矩形、圆角的xy轴半径以及画笔，就可以绘制圆角矩形背景了

//画背景，圆角矩形
canvas.drawRoundRect(mBgRect, mBgCornerRadius, mBgCornerRadius, mBgPaint);
Step 3：（绘制进度条圆弧）
// 圆弧这里我定义了四个配置项，半径、静态圆环颜色、进度条圆弧颜色以及进度条圆弧的宽度
mInnerRadius = typedArray.getDimensionPixelSize(R.styleable.ProgressView_innerRadius, 50);
mEdgeColor = typedArray.getColor(R.styleable.ProgressView_edgeColor, Color.RED);
mRingColor = typedArray.getColor(R.styleable.ProgressView_ringColor, Color.BLUE);
mRingWidth = typedArray.getDimensionPixelSize(R.styleable.ProgressView_ringWidth, 10);


//静态圆环背景画笔
mEdgePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
mEdgePaint.setColor(mEdgeColor);
mEdgePaint.setStrokeCap(Paint.Cap.ROUND);
mEdgePaint.setStrokeWidth(mRingWidth);
mEdgePaint.setStyle(Paint.Style.STROKE);
//动态进度条圆弧画笔
mPercentPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
mPercentPaint.setColor(mPercentColor);
mPercentPaint.setStyle(Paint.Style.FILL);
mPercentPaint.setTextSize(mPercentSize);
// 下面就先绘制静态的圆环，比较简单

 //画静态圆环，相当于进度为0时候的显示
canvas.drawCircle(centerX, centerY, mInnerRadius, mEdgePaint);
// 第二就要绘制进度圆弧了，绘制圆弧需要用到它对应的外切矩形，就是恰好包着圆弧所在圆的矩形，在的代码里面就是RectF这个类。因此，我们需要在onMeasure()中确定矩形的坐标。

//圆弧外切的矩形(在)
private RectF mOval;

/**
 * 初始化配置
 */
private void initProSettings(){
    ...
    mOval = new RectF();
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    centerX = getMeasuredWidth() / 2;
    centerY = getMeasuredHeight() / 2;

    ...
    //计算外切矩形的位置
    mOval.left = (centerX - mInnerRadius);
    mOval.top = (centerY - mInnerRadius);
    mOval.right = centerX + mInnerRadius;
    mOval.bottom = centerY + mInnerRadius;
}
// 外切的矩形只是确定了圆弧所在的圆，但是这个圆弧究竟要画多少（或者说这个这个圆弧究竟要占整个圆的多少，几分之几呢），这里需要计算出来的是圆弧扫过的角度。


/**
 * mPercent是指下载进度
 * 圆，一周是360度
 * 这里圆弧扫过的角度必须要乘以360
 */
progress = (float) mPercent / 100 * 360;
// 最后就是绘制进度了

//画进度条圆环
//第二个参数是指圆弧的起点在哪，这里是以3点钟方向为0度，因此我们这里写-90
//第三个参数true的意思就是要将圆弧与圆心连起来，也就是话一个扇形，画一个饼，这里我们不需要，设置为false
canvas.drawArc(mOval, -90, progress, false, mRingPaint);

Step 4： （绘制百分比文字）
// 文字这里定义了两个配置项，颜色和大小

mPercentColor = typedArray.getColor(R.styleable.ProgressView_percentColor, Color.GRAY);
mPercentSize = typedArray.getDimensionPixelSize(R.styleable.ProgressView_percentSize, 30);
// 初始化画笔

//字体的画笔
mPercentPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
mPercentPaint.setColor(mPercentColor);
mPercentPaint.setStyle(Paint.Style.FILL);
mPercentPaint.setTextSize(mPercentSize);

//计算字体的高度
Paint.FontMetrics fm = mPercentPaint.getFontMetrics();
mTextHeight = (int) Math.ceil(fm.descent - fm.ascent);
// 绘制字体（先调整一下文字的位置，使文字处于中间的位置）

//计算字体的宽度
mTextWidth = mPercentPaint.measureText(percentText, 0, percentText.length());
 //画百分比
canvas.drawText(percentText, centerX - mTextWidth / 2, centerY + mTextHeight / 4, mPercentPaint);

Step 5： （暴露接口给外部）
/**
 * 直接从外部设置百分比
 *
 * @param percent 百分比
 */
 public void setPercent(int percent) {
     this.mPercent = percent;
     //重绘
     postInvalidate();
 }
// 最后 模拟一下进度显示

<chengang.library.widget.LofterProgressView
    android:id="@+id/pv2"
    android:layout_width="100dp"
    android:layout_height="100dp"
    android:layout_centerInParent="true"
    android:visibility="visible"
    app:bgColor="@color/white"
    app:bgCornerRadius="12dp"
    app:bgWidth="70dp"
    app:edgeColor="@color/default_edge_color"
    app:innerColor="@color/white"
    app:innerRadius="17dp"
    app:percentColor="@color/gray"
    app:percentSize="11sp"
    app:ringColor="@color/default_ring_color"
    app:ringWidth="2dp" />
// 模拟下载图片

btnStart.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 101; i++) {
                    try {
                        lofterProgressView.setPercent(i);
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
});

3.打钩动画
圆环 + 钩
Step 1： （确定进度圆环和钩的位置）
无论是选中状态还是未选中状态，进度圆环和钩的位置是不变的，所以我们先来确定圆环的位置和钩的位置

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    ...
    //设置圆圈的外切矩形,radius是圆的半径，centerX，centerY是控件中心的坐标
    mRectF.set(centerX - radius, centerY - radius, centerX + radius, centerY + radius);

    //设置打钩的几个点坐标（具体坐标点的位置不用怎么理会，自己定一个就好，没有统一的标准）
    //画一个√，需要确定3个坐标点的位置
    //所以这里我先用一个float数组来记录3个坐标点的位置，
    //最后在onDraw()的时候使用canvas.drawLines(mPoints, mPaintTick)来画出来
    //其中这里mPoint[0]~mPoint[3]是确定第一条线"\"的两个坐标点位置
    //mPoint[4]~mPoint[7]是确定第二条线"/"的两个坐标点位置

    mPoints[0] = centerX - tickRadius + tickRadiusOffset;
    mPoints[1] = (float) centerY;
    mPoints[2] = centerX - tickRadius / 2 + tickRadiusOffset;
    mPoints[3] = centerY + tickRadius / 2;
    mPoints[4] = centerX - tickRadius / 2 + tickRadiusOffset;
    mPoints[5] = centerY + tickRadius / 2;
    mPoints[6] = centerX + tickRadius * 2 / 4 + tickRadiusOffset;
    mPoints[7] = centerY - tickRadius * 2 / 4;
}
Step 2：（定义变量，标记状态）
// 既然分选中状态和未选中状态，那个绘制过程中，就必须判断当前究竟是绘制未选中的呢还是选中了的呢。

// 因此在这里，我定义了一个变量isChecked

//是否被点亮
private boolean isChecked = false;

//暴露外部接口，改变绘制状态
public void setChecked(boolean checked) {
    if (this.isChecked != checked) {
        isChecked = checked;
        reset();
    }
}
Step 3：（绘制未选中状态） 
// 绘制过程中那些画笔就不详细说了，一开始初始化画笔最后绘制的时候调用即可

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    if (!isChecked) {
        //绘制圆环，mRectF就是之前确定的外切矩形
        //因为是静态的，所以设置扫过的角度为360度
        canvas.drawArc(mRectF, 90, 360, false, mPaintRing);

        //根据之前定好的钩的坐标位置，进行绘制
        canvas.drawLines(mPoints, mPaintTick);
        return;
    }
}
Step 4：（绘制选中状态）
// 选中状态是个动画，因此我们这里需要调用postInvalidate()不断进行重绘，直到动画执行完毕；
// 另外，我这里用计数器的方式来控制绘制的进度。


// 绘制进度圆环这里，我们定义一个计数器ringCounter,峰值为360（也就是360度），每执行一次onDraw()方法，我们对ringCounter进行自加，进而模拟进度。

// 最后记得调用postInvalidate()进行重绘

//计数器
private int ringCounter = 0;

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    if (!isChecked) {
        ...
        return;
    }
    //画圆弧进度，每次绘制都自加12个单位，也就是圆弧又扫过了12度
    //这里的12个单位先写死，后面我们可以做一个配置来实现自定义
    ringCounter += 12;
    if (ringCounter >= 360) {
        ringCounter = 360;
    }
    canvas.drawArc(mRectF, 90, ringCounter, false, mPaintRing);
    ...
    //强制重绘
    postInvalidate();
}

// 绘制向圆心收缩的动画
// 圆心收缩的动画在圆环进度达到100%的时候才进行，同理，也采用计数器circleCounter的方法来控制绘制的时间和速度

//计数器
private int circleCounter = 0;

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    ...
    //在圆环进度达到100%的时候才开始绘制
    if (ringCounter == 360) {
        //先绘制背景的圆
        mPaintCircle.setColor(checkBaseColor);
        canvas.drawCircle(centerX, centerY, radius, mPaintCircle);
        //然后在背景圆的图层上，再绘制白色的圆(半径不断缩小)
        //半径不断缩小，背景就不断露出来，达到向中心收缩的效果
        mPaintCircle.setColor(checkTickColor);
        //收缩的单位先试着设置为6，后面可以进行自己自定义
        circleCounter += 6;
        canvas.drawCircle(centerX, centerY, radius - circleCounter, mPaintCircle);
    }
    //必须重绘
    postInvalidate();
}
Step 5：（绘制钩子）
// 当白色的圆半径收缩到0后,就该绘制打钩了。

// 绘制打钩，这里问题不大，因为在onMeasure()中已经将钩的三个坐标点已经计算出来了，直接使用drawLine()即可画出来。

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    ...
    canvas.drawCircle(centerX, centerY, radius - circleCounter, mPaintCircle);
    //当白色的圆半径收缩到0后，
    //也就是计数器circleCounter大于背景圆的半径的时候，就该将钩√显示出来了
    //这里加40是为了加一个延迟时间，不那么仓促的将钩显示出来
    if (circleCounter >= radius + 40) {
        //显示打钩（外加一个透明的渐变）
        alphaCount += 20;
        if (alphaCount >= 255) alphaCount = 255;
        mPaintTick.setAlpha(alphaCount);
        //最后就将之前在onMeasure中计算好的坐标传进去，绘制钩出来
        canvas.drawLines(mPoints, mPaintTick);
    }
    postInvalidate();
}

// 绘制放大再回弹的效果
// 放大再回弹的效果，开始的时机应该也是收缩动画结束后开始，也就是说跟打钩的动画同时进行

// 因为这里要放大并且回弹，所以这里的计数器我设置成一个不为0的数值，先设置成45（随意，这不是标准），然后没重绘一次，自减4个单位。

// 最后画笔的宽度是关键的地方，画笔的宽度根据scaleCounter的正负来决定是加还是减

//计数器
private int scaleCounter = 45;

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    ...
    if (circleCounter >= radius + 40) {
        //显示打钩
       ...
        //显示放大并回弹的效果
        scaleCounter -= 4;
        if (scaleCounter <= -45) {
            scaleCounter = -45;
        }
        //放大回弹，主要看画笔的宽度
        float strokeWith = mPaintRing.getStrokeWidth() + 
            (scaleCounter > 0 ? dp2px(mContext, 1) : -dp2px(mContext, 1));
        mPaintRing.setStrokeWidth(strokeWith);
        canvas.drawArc(mRectF, 90, 360, false, mPaintRing);
    }
    //动画执行完毕，就补在需要重绘了
    if (scaleCounter != -45) {
        postInvalidate();
    }
}
Step 6：（暴露外部接口）
// 为了灵活的可以控制绘制的状态，我们可以暴露一个接口给外部设置是否选中

/**
 *  是否选中
 */
public void setChecked(boolean checked) {
    if (this.isChecked != checked) {
        isChecked = checked;
        reset();
    }
}

/**
 *  重置，并重绘
 */
private void reset() {
    //画笔重置
    ...
    //计数器重置
    ringCounter = 0;
    circleCounter = 0;
    scaleCounter = 45;
    alphaCount = 0;
    ...
    invalidate();
}
// 添加点击事件
// 控件到这里已经基本做好了，但还不是特别的完善。

// 想想checkbox，它不需要暴露外部接口也能通过点击控件来实现选中还是取消选中，所以接下来要实现的就是为控件添加点击事件

// 先定义一个接口OnCheckedChangeListener,实现监听此控件的监听事件

private OnCheckedChangeListener mOnCheckedChangeListener;

public interface OnCheckedChangeListener {
    void onCheckedChanged(TickView tickView, boolean isCheck);
}

public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
    this.mOnCheckedChangeListener = listener;
}
// 接下来，初始化控件的点击事件

/**
 * 在构造函数中初始化
 */
public TickView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    ...
    setUpEvent();
}

/**
 * 初始化点击事件
 */
private void setUpEvent() {
    this.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View view) {
            isChecked = !isChecked;
            reset();
            if (mOnCheckedChangeListener != null) {
                //此处回调
                mOnCheckedChangeListener.onCheckedChanged((TickView) view, isChecked);
            }
        }
    });
}
<declare-styleable name="TickView">
    <!--没有选中的基调颜色-->
    <attr name="uncheck_base_color" format="color" />
    <!--选中后的基调颜色-->
    <attr name="check_base_color" format="color" />
    <!--选中后钩的颜色-->
    <attr name="check_tick_color" format="color" />
    <!--圆的半径-->
    <attr name="radius" format="dimension" />
    <!--动画执行的速度-->
    <attr name="rate">
        <enum name="slow" value="0"/>
        <enum name="normal" value="1"/>
        <enum name="fast" value="2"/>
    </attr>
</declare-styleable>
这里简单说一下动画执行速度的配置，这里我设置了3档速度，我用枚举定义了三个速度的配置项

enum TickRateEnum {

    //低速
    SLOW(6, 4, 2),
    //正常速度
    NORMAL(12, 6, 4),
    //高速
    FAST(20, 14, 8);

    public static final int RATE_MODE_SLOW = 0;
    public static final int RATE_MODE_NORMAL = 1;
    public static final int RATE_MODE_FAST = 2;

    //圆环进度增加的单位
    private int ringCounterUnit;
    //圆圈收缩的单位
    private int circleCounterUnit;
    //圆圈最后放大收缩的单位
    private int scaleCounterUnit;
    
    public static TickRateEnum getRateEnum(int rateMode) {
        TickRateEnum tickRateEnum;
        switch (rateMode) {
            case RATE_MODE_SLOW:
                tickRateEnum = TickRateEnum.SLOW;
                break;
            case RATE_MODE_NORMAL:
                tickRateEnum = TickRateEnum.NORMAL;
                break;
            case RATE_MODE_FAST:
                tickRateEnum = TickRateEnum.FAST;
                break;
            default:
                tickRateEnum = TickRateEnum.NORMAL;
                break;
        }
        return tickRateEnum;
    }

    ...
}

获取xml的配置，获取对应的枚举，从而得到配好的动画速度的一些参数

/**
 * 构造函数
 */
public TickView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    ...
    initAttrs(attrs);
}

/**
 * 获取自定义配置
 */
private void initAttrs(AttributeSet attrs) {
    TypedArray typedArray = mContext.obtainStyledAttributes(attrs, R.styleable.TickView);
    ...
    //获取配置的动画速度
    int rateMode = typedArray.getInt(R.styleable.TickView_rate, TickRateEnum.RATE_MODE_NORMAL);
    mTickRateEnum = TickRateEnum.getRateEnum(rateMode);
    typedArray.recycle();
}


##### 卡片轮播
```bash
[https://upload-images.jianshu.io/upload_images/5981775-3c80693fb34a89df.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp]

//recyclerview滑动监听
hignHeadRecycler.addOnScrollListener(new RecyclerView.OnScrollListener() {
    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        super.onScrolled(recyclerView, dx, dy);
        int childCount = recyclerView.getChildCount();//总item的数量
        int width = recyclerView.getChildAt(0).getWidth();//第一个item的宽度
        int padding = (recyclerView.getWidth() - width) / 2;//这个padding是 recycler的宽度减去第一个item的宽度然后除以2，作为padding
        for (int j = 0; j < childCount; j++) {
            View v = recyclerView.getChildAt(j);//获取每一个child
            float rate = 0;//是一个缩放比例
            if (v.getLeft() <= padding) {//如果view距离左边的宽度 小于等于 左侧剩余空间(padding) （意味着这个view开始往左边滑动了，并且有遮挡）
                if (v.getLeft() >= padding - v.getWidth()) {//如果view距离左边的距离 小于等于滑进去的距离 （其实就是说滑动到一半的时候）
                    rate = (padding - v.getLeft()) * 1f / v.getWidth();//（这个比例的计算结果一般都会大于1，这样一来，根据下面的 1- rate * 0.1 得出，这个比例最多不会到达1，也就是 1- 0.1， 也就是 0.9， 所以这个view的宽度最大不会小于他本身的90%）
                } else {
                    rate = 1;
                }
                v.setScaleY(1 - rate * 0.1f);
            } else {
                if (v.getLeft() <= recyclerView.getWidth() - padding) {//这个过程大概是指这个view 从最后侧刚刚出现的时候开始滑动过padding的距离
                    rate = (recyclerView.getWidth() - padding - v.getLeft()) * 1f / v.getWidth();
                }
                v.setScaleY(0.9f + rate * 0.1f);
            }
        }

    }
});
 

//加载完成后的监听
hignHeadRecycler.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {
    @Override
    public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
        if (hignHeadRecycler.getChildCount() < 3) {
            if (hignHeadRecycler.getChildAt(1) != null) {
                View v1 = hignHeadRecycler.getChildAt(1);
                v1.setScaleY(0.9f);
            }
        } else {
            if (hignHeadRecycler.getChildAt(0) != null) {
                View v0 = hignHeadRecycler.getChildAt(0);
                v0.setScaleY(0.9f);
            }
            if (hignHeadRecycler.getChildAt(2) != null) {
                View v2 = hignHeadRecycler.getChildAt(2);
                v2.setScaleY(0.9f);
            }
        }
    }
});
```

##### google-services.json
https://console.firebase.google.com/u/0
注册应用下载json

##### android 扩展包
Rxjava io任务计划处理
https://www.2cto.com/kf/201601/485780.html
rxjava
http://www.gcssloop.com/gebug/rclayout

android 使用font文件
http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0925/3518.html


android layout
http://rkhcy.github.io/2017/12/22/%E5%9B%BE%E8%A7%A3RxJava2(%E4%B8%89)/


android 图像处理
https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247489265&idx=1&sn=58bf6498c1b6d172964bf6dd00fa4325


android lottie
https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247489401&idx=1&sn=9eecc9faa9d2dc0ce8bae6d7c45885a9


android加载
https://fashare2015.github.io/2018/01/24/dynamic-load-learning-load-activity/


http://roynotes.com/blog/2012/11/problems-with-meteor/

Retrofit 网络请求
http://www.cnblogs.com/angeldevil/p/3757335.html
https://blog.csdn.net/u014165119/article/details/49280779


Make a cool intro for your Android app.（addSlide）
com.github.paolorotolo:appintro
https://github.com/PaoloRotolo/AppIntro


为"单Activity ＋ 多Fragment","多模块Activity + 多Fragment"架构而生，简化开发，轻松解决动画、嵌套、事务相关等问题。
me.yokeyword:fragmentation
https://github.com/YoKeyword/Fragmentation


This component that mimics the new Material Design Bottom Navigation pattern.
com.ashokvarma.android:bottom-navigation-bar
https://github.com/Ashok-Varma/BottomNavigation


基于IJKPlayer（兼容系统MediaPlayer与EXOPlayer2），实现了多功能的视频播放器。 (请仔细阅读下方各项说明，大多数问题可在下方找到解答)。
com.shuyu:GSYVideoPlayer
https://github.com/CarGuo/GSYVideoPlayer

##### mvp模式
Presenter是来自MVP中的概念，是用来处理与用户交互的逻辑。
在这里更加简单化，Presenter中的方法是根据业务来定义。
比如获取消息列表，那么业务常常会这样：先去请求网络，网络正常请求到数据返回并展示在UI层，网络错误没有拿到数据，看看缓存中有没有，然后从缓存中拿到数据并返回并展示在UI层；
突然，有一天业务需求发生变化，只允许获取网络，网络错误UI上显示没有消息。
如果之前在UI层已经做过数据为空的处理，那么UI层就不用修改任何代码，仅仅只需要修改presenter层，这样就将UI层和业务层区分，并且耦合降低了。


##### android interface中不能有实体类，但可以有抽象类和静态类
public interface EssayHomeContract {
    interface View extends BaseView {
        void showContent(List<DataBean> dataBeanList);
        void error(Throwable throwable);
    }

    interface Model extends BaseModel {
        void loadEssayData(int id);
    }

    abstract class Presenter extends BasePresenter<View, Model> {
        abstract void getEssayData(int id);

    }
}

##### 反编译工具
echo 'export PATH="$PATH:/Users/xiaoyu/Documents/master/Android不倒/dex2jar-2.0"' >> ~/.bash_profile
echo 'export PATH="$PATH:/Users/xiaoyu/Documents/master/Android不倒/apktool1.5.2"' >> ~/.bash_profile


apktool d -f 豆瓣_6.3.0.apk
apk 重命名为 zip格式 解压缩得到 dex文件
dex2jar.sh classes.dex classes2.dex ... //将得到jar文件(d2j-dex2jar.sh)
jd-gui 打开jar文件可以查看源码


dex2jar 指定下载地址
https://sourceforge.net/p/dex2jar/wiki/Home/（有github bitbucket 2015年之后不再更新最后版本2.0）


##### 音频开发

音频开发主要应用有
1.1 音频播放器，录音机，语音电话，音视频直播应用，音频编辑处理软件，蓝牙耳机、音箱等。
音频开发具体内容有
2.1 音频采集与播放
2.2 音频算法处理（去噪，静音检测，回事消除，音效处理，功放/增强，混音/分离）
2.3 音频编解码和格式转换
2.4 音频传输协议的开发（SIP，A2DP, AVRCP，RTP,RTCP）
音频应用的难点
3.1 延时敏感、卡顿明感、噪声抑制、回声消除、静音检测、混音算法等。
音频开发基础概念有
4.1 采样率，采样是从模拟语音信号转数字信号的过程，所有的模拟信号都需要通过采样转为可以表示的数字信号。目前44100Hz是唯一可以保证兼容所有Android手机的采样率。
4.2 奈奎斯特理论：采样频率不低于音频信号最高频率的两倍，就可以做到无误还原原始的声音。通常人耳能听到的20HZ-20KHZ的声音，为了保证不失真，采样频率应该在40KHZ以上。
4.3 量化精度（位宽），每一个采样点，都需要一个数值来表示大小，这个大小可以是4bit，8bit，16bit… 位数越多，表示越精细，声音质量就越好，当然，数据量也成倍增大。ENCODING_PCM_16BIT是可以保证兼容所有Android手机的。
4.4 声道数，音频可以从不同的音频源采集并输出到不同的扬声器，一般表示声音录制时的音源数量或者回放时相应的扬声器数量。常见有单身道mono及双声道stereo。
4.5 音频帧，音频数据和视频帧不一样，视频帧就是一张图像，音频数据是流式结构，本身没有明确的一帧的概念，只是为了音频算法处理传输方便，约定2.5ms~60ms为单位的数据量为一帧音频。这个时间为采样时间。AndioRecord内部的音频缓冲区大小不能低于一帧音频帧的大小。一帧音频帧大小：int size = 采样率x位宽x采样时间x通道数。AudioRecord类提供了一个帮助我们确定缓冲区大小的函数，int getMinBufferSize(int sampleRateInHz, int channelConfig,int audioFormat)。假设某双通道音频信号采样率为8k，位宽16bit，20ms一帧的采样时间。则一帧数据的大小为：size = 8000x16x0.02x2 = 640byte（字节）
常见音频编码方式
5.1 A/D需要采样和量化，对应上面提到的采样率和量化宽度。量化的过程被称为编码，根据不同的量化策略，有不同的编码方式，常见有PCM，ADPCM。这些数据代表了无损的原始数字音频信号，添加一些文件头信息，就可以存储为wav文件了。
5.2 获取不同手机终端的编解码分辨率，可以通过adb工具获取/system/etc/media_codecs.xml文件。
常见音频压缩格式
原理：因为有冗余信息，所以需要压缩
6.1 频谱掩蔽效应：人耳能察觉到的频率范围为20hz-20khz，在这个频率范围之外的音频信号属于冗余信号。

6.2 时域掩蔽效应：当强音信号和弱音信号同时出现时，弱信号会听不到，因此此时弱音信号也属于冗余信号。

Android VoIP 相关的开源应用有
7.1 Imsdroid，sipdroid，csipsimple，linephone，WebRTC等。

音频算法处理的开源库有
8.1 Speex，ffmpeg，webrtc

Android 提供音频相关的API
9.1 音频采集：MediaRecoder，AudioRecord
AudioTrack 提供了两种播放模式，一种是static方式，一种是streaming方式，前者需要一次性将所有数据都写入播放缓冲区，简单高效，通常用于铃声播放，系统提醒的音频片段，后者需要按照一定时间间隔不断写入音频数据，理论上可以任何音频播放的场景。

9.2 音频播放：SoundPool，MediaPlayer，AudioTrack

9.3 音频编解码：MediaCodec

9.4 NDK API：OpenSL ES

音频开发的延时标准
10.1 对于高质量语音可以接受延时为300ms，一般而言，如果时延在300~400ms，通话的交互性比较差，但还可以接受，时延大于400ms时，则交互通信非常困难。

libavcodec.so
libavdevice.so
libavfilter.so
libavformat.so
libavutil.so
libpostproc.so
libswresample.so 音频的重采样，采样，混合
libswscale.so


extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。


##### ScaleType
center          局中显示        图片不缩放       图片尺寸超出View将被裁减
centerCrop      局中显示        图片按比例缩放 图片填满整个View(宽高缩放填充View，图片宽<高>小以宽填充View宽<高>为主)
centerInside    局中显示        图片按比例缩放 图片完整的显示在View(宽高缩放填充View，图片宽<高>大以宽填充View宽<高>为主)
fitCenter       局中显示        图片按比例缩放 图片宽等于View宽
fitEnd          View底部显示    图片按比例缩放 图片宽等于View宽
fitStart        View顶部显示    图片按比例缩放 图片宽等于View宽
fitXY                       图片不按比例缩放    图片填满整个View
matrix          左上开始显示  图片不缩放       图片超出View部分被裁剪


##### Android进程通信IPC(Internet Process Connection)
Linux的IPC Pipe，Signal,Trace,Socket,Message(消息队列),ShareMemory(共享内存),Semaphore(信号量)

socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。
消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。
共享内存虽然无需拷贝，但控制复杂，难以使用。


传统IPC的接收方无法获得对方进程可靠的UID和PID（用户ID进程ID）


IPC                 数据拷贝次数          
共享内存                 0           
Binder                  1
Socket/管道/消息队列      2


对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。


##### inflate(int resource, ViewGroup root, boolean attachToRoot)
1. 如果root为null，attachToRoot将失去作用，设置任何值都没有意义。

2. 如果root不为null，attachToRoot设为true，则会给加载的布局文件的指定一个父布局，即root。

3. 如果root不为null，attachToRoot设为false，则会将布局文件最外层的所有layout属性进行设置，当该view被添加到父view当中时，这些layout属性会自动生效。

4. 在不设置attachToRoot参数的情况下，如果root不为null，attachToRoot参数默认为true。


##### 自定义Behavior实现底部View的平移动画
```bash
CoordinatorLayout，通过实现NestedScrollingParent接口，配合子View实现NestedScrollingChild接口可以实现各种酷炫效果
比如说Toolbar的伸缩效果，我们都知道CoordinatorLayout嵌套Toolbar之后给Toolbar设置
app:layout_scrollFlags=”scroll|enterAlways”，
并给可以滚动的视图设置
app:layout_behavior=”@string/appbar_scrolling_view_behavior”
之后，Toolbar在视图滚动的时候有一个上下平移动画

需求是实现列表RecyclerView滑动的时候底部布局自动隐藏和显示 
贴出Behavior的代码，这份代码差不多是照搬了BottomNavigationBar源码中Behavior的实现
public class FootBehavior<V extends View> extends CoordinatorLayout.Behavior<V> {

    private int mTotalDyUnconsumed = 0;
    private int mTotalDyConsumed = 0;
    private int mTotalDy = 0;

    private static final Interpolator INTERPOLATOR = new LinearOutSlowInInterpolator ();
    private int mFootViewHeight;
    private int mDefaultOffset;

    private ViewPropertyAnimatorCompat mTranslationAnimator;
    private boolean hidden = false;

    @ScrollDirection
    private int mScrollDirection = ScrollDirection.SCROLL_NONE;
    @ScrollDirection
    private int mPreScrollDirection = ScrollDirection.SCROLL_NONE;
    @ScrollDirection
    private int mConsumedScrollDirection = ScrollDirection.SCROLL_NONE;

    public FootBehavior () {
        super ();
    }

    public FootBehavior (Context context, AttributeSet attrs) {
        super (context, attrs);
    }

    @Retention (RetentionPolicy.SOURCE)
    @IntDef ({ScrollDirection.SCROLL_DIRECTION_UP, ScrollDirection.SCROLL_DIRECTION_DOWN})
    public @interface ScrollDirection {
        int SCROLL_DIRECTION_UP = 1;
        int SCROLL_DIRECTION_DOWN = -1;
        int SCROLL_NONE = 0;
    }


    @ScrollDirection
    public int getScrollDirection () {
        return mScrollDirection;
    }


    @ScrollDirection
    public int getConsumedScrollDirection () {
        return mConsumedScrollDirection;
    }


    @ScrollDirection
    public int getPreScrollDirection () {
        return mPreScrollDirection;
    }


    @Override
    public boolean onLayoutChild (CoordinatorLayout parent, final V child, int layoutDirection) {
        parent.onLayoutChild (child, layoutDirection);

        child.post (new Runnable () {
            @Override
            public void run () {
                mFootViewHeight = child.getHeight ();
            }
        });

        mDefaultOffset = 0;

        return super.onLayoutChild (parent, child, layoutDirection);
    }

    //判断是否接受后续滑动事件
    @Override
    public boolean onStartNestedScroll (CoordinatorLayout coordinatorLayout, V child,
                                        View directTargetChild, View target, int nestedScrollAxes) {

        return (nestedScrollAxes & View.SCROLL_AXIS_VERTICAL) != 0;
    }


    //进行滑动事件处理
    @Override
    public void onNestedScroll (CoordinatorLayout coordinatorLayout, V child, View target,
                                int dxConsumed, int dyConsumed, int dxUnconsumed,
                                int dyUnconsumed) {
        super.onNestedScroll (coordinatorLayout, child, target, dxConsumed, dyConsumed,
                dxUnconsumed, dyUnconsumed);
        if (dyUnconsumed > 0 && mTotalDyUnconsumed < 0) {
            mTotalDyUnconsumed = 0;
            mScrollDirection = ScrollDirection.SCROLL_DIRECTION_UP;
            onNestedVerticalScrollUnconsumed (coordinatorLayout, child, mScrollDirection,
                    dyConsumed, mTotalDyUnconsumed);
        } else if (dyUnconsumed < 0 && mTotalDyUnconsumed > 0) {
            mTotalDyUnconsumed = 0;
            mScrollDirection = ScrollDirection.SCROLL_DIRECTION_DOWN;
            onNestedVerticalScrollUnconsumed (coordinatorLayout, child, mScrollDirection,
                    dyConsumed, mTotalDyUnconsumed);
        }
        mTotalDyUnconsumed += dyUnconsumed;

        if (dyConsumed > 0 && mTotalDyConsumed < 0) {
            mTotalDyConsumed = 0;
            mConsumedScrollDirection = ScrollDirection.SCROLL_DIRECTION_UP;
            onNestedVerticalScrollConsumed (coordinatorLayout, child, mConsumedScrollDirection,
                    dyConsumed, mTotalDyConsumed);
        } else if (dyConsumed < 0 && mTotalDyConsumed > 0) {
            mTotalDyConsumed = 0;
            mConsumedScrollDirection = ScrollDirection.SCROLL_DIRECTION_DOWN;
            onNestedVerticalScrollConsumed (coordinatorLayout, child, mConsumedScrollDirection,
                    dyConsumed, mTotalDyConsumed);
        }
        mTotalDyConsumed += dyConsumed;
    }

    @Override
    public void onNestedPreScroll (CoordinatorLayout coordinatorLayout, V child, View target,
                                   int dx, int dy, int[] consumed) {
        super.onNestedPreScroll (coordinatorLayout, child, target, dx, dy, consumed);
        if (dy > 0 && mTotalDy < 0) {
            mTotalDy = 0;
            mPreScrollDirection = ScrollDirection.SCROLL_DIRECTION_UP;
            onNestedVerticalPreScroll (coordinatorLayout, child, target, dx, dy, consumed,
                    mPreScrollDirection);
        } else if (dy < 0 && mTotalDy > 0) {
            mTotalDy = 0;
            mPreScrollDirection = ScrollDirection.SCROLL_DIRECTION_DOWN;
            onNestedVerticalPreScroll (coordinatorLayout, child, target, dx, dy, consumed,
                    mPreScrollDirection);
        }
        mTotalDy += dy;
    }


    //当进行快速滑动
    @Override
    public boolean onNestedFling (CoordinatorLayout coordinatorLayout, V child, View target,
                                  float velocityX, float velocityY, boolean consumed) {
        super.onNestedFling (coordinatorLayout, child, target, velocityX, velocityY, consumed);
        return onNestedDirectionFling (coordinatorLayout, child, target, velocityX, velocityY,
                consumed,
                velocityY > 0 ? ScrollDirection.SCROLL_DIRECTION_UP : ScrollDirection.SCROLL_DIRECTION_DOWN);
    }


    public void onNestedVerticalScrollUnconsumed (CoordinatorLayout coordinatorLayout, V child,
                                                  @ScrollDirection int scrollDirection,
                                                  int currentOverScroll, int totalScroll) {

    }


    public void onNestedVerticalScrollConsumed (CoordinatorLayout coordinatorLayout, V child,
                                                @ScrollDirection int scrollDirection,
                                                int currentOverScroll, int totalConsumedScroll) {
        handleDirection (child, scrollDirection);
    }

    private void handleDirection (V child, int scrollDirection) {
        if (scrollDirection == ScrollDirection.SCROLL_DIRECTION_DOWN && hidden) {
            hidden = false;
            animateOffset (child, mDefaultOffset);
        } else if (scrollDirection == ScrollDirection.SCROLL_DIRECTION_UP && !hidden) {
            hidden = true;
            animateOffset (child, mFootViewHeight + mDefaultOffset);
        }
    }

    private void animateOffset (V child, int offset) {
        ensureOrCancelAnimator (child);
        mTranslationAnimator.translationY (offset).start ();
    }

    private void ensureOrCancelAnimator (V child) {
        if (mTranslationAnimator == null) {
            mTranslationAnimator = ViewCompat.animate (child);
            mTranslationAnimator.setDuration (400);
            mTranslationAnimator.setInterpolator (INTERPOLATOR);
        } else {
            mTranslationAnimator.cancel ();
        }
    }


    public void onNestedVerticalPreScroll (CoordinatorLayout coordinatorLayout, V child,
                                           View target, int dx, int dy, int[] consumed,
                                           @ScrollDirection int scrollDirection) {

    }


    protected boolean onNestedDirectionFling (CoordinatorLayout coordinatorLayout, V child,
                                              View target, float velocityX, float velocityY,
                                              boolean consumed,
                                              @ScrollDirection int scrollDirection) {
        if (consumed) {
            handleDirection (child, scrollDirection);
        }
        return consumed;
    }


}

<LinearLayout
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:layout_gravity="bottom"
    android:background="?attr/colorPrimary"
    android:gravity="center_vertical"
    android:orientation="horizontal"
    app:layout_behavior="com.mteeyu.behaviordemo.FootBehavior"
    >

    <android.support.v7.widget.AppCompatImageView
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_marginLeft="10dp"
        android:background="@drawable/ic_mood"/>

    <android.support.v7.widget.AppCompatEditText
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_margin="10dp"
        android:background="#FFF"/>

</LinearLayout>


FootBehavior继承的是CoordinatorLayout.Behavior这个类，所以需要使用的时候，布局文件最外层就必须是CoordinatorLayout。
值得一提的是，CoordinatorLayout中填充RecyclerView或者NestedScrollingView可以触发动画，
但是像我们很熟悉的ListView，GridView等是触发不了的

项目地址 
https://github.com/MteeYu/BehaviorDemo
```

##### Animation 动画
```bash
Android中的动画:

游戏：利用自定义View的绘制方法，开启线程频繁的刷新界面，形成动画；
Android 视图动画：针对 View 以及View的子类。
Android 属性动画：针对定义的属性，大部分可以操作View
补间动画：Android根据起始状态和结束状态，进行控件的移动、旋转、缩放等显示效果的变化，形成一个动画

实现方式
XML 定义动画 (Android官方推荐) 
xml 定义在 res/anim/ 文件夹下面；
这种 anim动画，需要通过 AnimationUtils 来加载
代码实现动画（可扩展性差）

补间动画，就是指定开始状态，并且指定结束状态，Android系统自动的在这两个状态之间进行填充，形成连续的动画，就被称为补间动画

代码从XML中加载 动画对象；
给需要处理的控件，设置动画就可以播放了；
补间动画特点
通过指定时间、起始状态、结束状态，通过Android系统API，来进行动态效果的呈现；
补间动画，播放完成执行，控件将会还原为原始的位置、状态；
可以根据动画的播放情况，进行动画的播放状态的监听， 通过监听器可以监测：动画的开始、循环、停止；
当动画还在播放的时候，如果再次设置控件的动画，那么当前的动画将会终止；
关于动画的平滑
Android系统，播放补间动画时，根据时间，起始状态、结束状态，生成动画效果
插值器 interpolator: Android系统根据插值器，在每一个等分的时间中，来设置不同的数值
组合变化
translate + scale 在 中，写入多个动画效果就可以将多种效果同时组合在一起播放。
如果希望动画是串行执行，那么后续动画的起始播放时间，需要延后！！！
补间动画的 set 最终相当于线程池，内部的每一个动画效果实际上是由一个线程执行的，所有即使一个效果无限循环，其他效果也能够执行。
补间动画的重点
！！！ 任何动画的操作都不会影响实际控件的状态。因为实际上补间动画只是把控件的外观进行了各种处理，相当于控件还在原来的位置，还是原来的尺寸
尝试 translate + rotate 就可以重现控件状态。
补间动画 通过 AnimationUtils.loadAnimation 进行加载的。给控件 View startAnimation(Animation) 就可以执行控件的动画了。
关于动画的接口
动画播放的时候是有状态了，例如 开始动画、动画结束 
AnimationListener 包含动画三种状态的回调：

onAnimationStart 动画开始执行
onAnimationEnd 动画执行完成
onAnimationRepeat 动画重复执行。
几种动画效果
xml文件 
res/anim/

旋转:

<!--
    android:repeatCount="infinite" 循环次数:无限循环
    android:interpolator="@android:interpolator/linear": 可以平滑旋转

-->
<rotate
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="500"
    android:fromDegrees="0"
    android:toDegrees="360"
    android:pivotX="50%"
    android:pivotY="50%"
    android:repeatCount="infinite"
    />
移动:

    <translate
        android:fromXDelta="0"
        android:toXDelta="200"/>
缩放:

  <!--
    缩放视图, 必须包含x, y的缩放设置
     若不设置: 默认 0 -> 0
    -->
    <scale android:fromXScale="1"
           android:toXScale="2"
            android:fromYScale="1"
           android:toYScale="2"
           android:pivotX="50%"
           android:pivotY="50%"/>
set集合

<?xml version="1.0" encoding="utf-8"?>
<!--
    动画定义的集合, 使用set来包含多个动画
    如果只有一个动画效果, 可以直接写动画的指令
    duration: 持续时间
    Delta: 增量
    startOffset: 代表当前效果在动画启动多长时间之后 执行

    补间动画实际上没有操作控件的属性
    而是把控件的显示调整了 动画播放完成后还会还原原始状态


    Android的坐标系, 左上角为圆点!!!
-->
<set xmlns:android="http://schemas.android.com/apk/res/android">
    <!--所有的动画效果, 都需要设置duration属性-->
    <translate
        android:duration="1000"
        android:fromYDelta="0"
        android:toYDelta="-300"
        android:fromXDelta="0"
        android:toXDelta="-300"
        />
    <!--alpha 让控件逐渐消失和显示
        startOffset 代表当前效果在动画启动多长时间之后执行 , 单位: 毫秒

    -->
    <alpha

        android:duration="1000"
        android:fromAlpha="1"
        android:toAlpha="0"/>
</set>

public void btnRotateClick(View view) {
        //图片旋转
        Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_rotate);
        animation.setRepeatMode(Animation.INFINITE);

        //设置插值器 平滑旋转
        animation.setInterpolator(new LinearInterpolator());

        view.startAnimation(animation);


    }

    public void btMoveInterpolator(View view) {
        //带有插值器的移动
        Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_move);
        animation.setDuration(1000);
//        animation.setInterpolator(new OvershootInterpolator(20));
        animation.setInterpolator(new SimpleInterpolator());

        view.startAnimation(animation);
    }

    public void btnScale(View view) {
        ImageView imageView = (ImageView) findViewById(R.id.image_view);
        if (imageView != null) {
            Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_heartbeat);
            animation.setDuration(1000);
            AnimationSet animationSet = (AnimationSet) animation;
            List<Animation> animations = animationSet.getAnimations();
            Animation anim = animations.get(0);

            //设置第一次执行完成之后, 循环播放的次数
            anim.setRepeatMode(Animation.REVERSE);
            anim.setRepeatCount(Animation.INFINITE);
            imageView.startAnimation(animation);
        }
    }
动画的监听
设置动画监听: 当动画开始, 完成, 重复时, 进行回调
        animation.setAnimationListener(this);

 //////////////Animaition监听/////start/////////////
   @Override
    public void onAnimationStart(Animation animation) {

    }

    @Override
    public void onAnimationEnd(Animation animation) {
        tvInc.setVisibility(View.INVISIBLE);

        tvZan.setText("赞" + zanCount);
    }

    @Override
    public void onAnimationRepeat(Animation animation) {

    }
    //////////////Animaition监听///////end/////////////

逐帧动画
！！！ 逐帧动画是一个 drawable 可以认为是一个图片；和 shape 相似都是用 xml 写出来的。
当中，从 xml 顺序加载图片，最上面的 最先显示。
可以指定 oneshoot 属性，控制动画是否只播放一次。如果为 true,那么只播放一次，即使播放完成， 如果不进行stop的话，依然是 running的状态。代表直接start()是不会执行的，只有stop之后才可以重新start
逐帧动画的使用
准备图片资源
在drawable中编写 xml，指定每一帧的显示图片内容
ImageView 或者 其他View 的background属性，指定资源，方式：@drawable/名称
代码获取ImageView ，并且获取到 background ，检查是否是 AnimationDrawable ，进行强制类型转换
AnimationDrawable start(), stop(); 进行播放的控制
start() 不支持继续播放，每次从头开始。
应用场景
重复的，有动画效果的提示性内容，例如：京东客户端下拉刷新的时候“快递小哥”的动画
一些小的动画，不能够使用补间动画的情况，或者显示现实世界中的人物、动画的动态效果。
主要是配合一些事件的操作，如下拉刷新、圆圈进度条的处理
代码示例
<!--
        逐帧动画, 就是在指定时间中, 依次显示每一张图片
        形成连续的动画效果
        android:oneshot="true"
        如何显示是关键
-->

<animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    >

    <item android:duration="200" android:drawable="@mipmap/d00"/>
         .....
    <item android:duration="200" android:drawable="@mipmap/d09"/>

</animation-list>

    public void btnPlayFrame(View view) {
        //TODO: 播放动画
        //1. 因为逐帧动画是图片, 所以要从ImageView中取出来, 才能进行控制
        ImageView imageGift = (ImageView) findViewById(R.id.image_gift);
        //获取src属性
        Drawable drawable = imageGift.getDrawable();

        //shape -> ShapeDrawable
        //animation-list -> AnimationDrawable
        if (drawable != null && drawable instanceof AnimationDrawable) {
            //2. 播放动画
            AnimationDrawable animationDrawable = (AnimationDrawable) drawable;
            animationDrawable.start();
        }



//        imageGift.setImageDrawable();
    }


    public void btnStopFrame(View view) {
        //TODO: 停止动画
        //1. 获取图像 逐帧动画

        ImageView imageGift = (ImageView) findViewById(R.id.image_gift);
        Drawable drawable = imageGift.getDrawable();
        if (drawable != null && drawable instanceof AnimationDrawable) {
            AnimationDrawable animationDrawable = (AnimationDrawable) drawable;

            //Stop会将动画暂停, 但是下一次, start的时候, 会从头开始播放
            animationDrawable.stop();

            //Gif 如何显示: GifDrawable库  WebView

        }
    }
属性动画
属性动画定义在 res/animator/ 这个资源目录下；
属性动画：实现按时间进行控件属性的变化；
实际改变控件的属性，整个布局重新排版，而且不会还原。
objectAnimator标记
能够以动画的方式修改任意对象的属性；
能够通过 setXxxx 这种方法的自动调用，来实现对属性“xxxx” 来进行修改；
这个标记可以通过 指定属性的名称，来进行设置。

执行原理

Animator 通过 xml 来加载，获取需要修改的属性的名称、类型、数值；
AnimatorInflator 来加载xml, 之后设置了 setTarget(Object) ，指定需要修改属性的内容的对象；
通过将属性的名称转为 JavaBean 属性方法设置命名规则：属性名首字母大写，前面添加 set，例如 left属性，那么就会生成 setLeft(数值类型) 进行反射，查找指定对象中是否包含这个方法，如果包含，就可以按照指定的时间(duration) 进行 valueFrom 到 valueTo 这两值之间的进行动态的设置。
实现步骤
准备属性动画的XML动画资源；
准备需要播放动画的对象；
加载属性动画的 XML
设置动画要修改的对象
修改的属性名称，一定是 Java类文件中的 public void setXxxxx(… xxx) 的方法的 xxxx 这个属性，首字母小写
属性动画的Target的设置
比较常见的是 View
修改的属性都是 color, dimension, int, float
属性动画还可以指定非 View的对象。官方使用采用的自定义的Object，然后再Object setXxxx() 内部来实现更强大功能。 

动画执行序列 < set>
set 标签可以 通过 ordering属性进行设置，内部的动画是否在一起执行 
sequentially 串行执行，一个执行完，在执行另外的一个，不要有无限重复的，因为后边的没法执行了 
together 并行一起执行

V4包动画支持
ViewCompat 支持 设置View的状态，例如 ViewCompat.setScaleX(View, float) 就是缩放控件水平方向的尺寸； 
ViewPropertyAnimatorCompat 支持 实现低版本手机的属性动画功能， 
ViewCompat.animate(View) 为View创建一个属性动画对象

动画与事件的配合
ScrollView 的 onTouch 中的 MOVE 事件可以和控件的隐藏显示配合 
ListView OnScrollListener 可以检测ListView的滚动，滚动的过程中可以实现图片，标题的缩放

 <!--
        设置对象属性修改器, 可以在指定的时间之内,
         将指定的属性, 从一个数值变换到另一个数值
     -->

    <!-- setTranslationX(float x)-->

    <objectAnimator
        android:duration="1000"
        android:propertyName="translationX"
        android:valueType="floatType"
        android:valueFrom="0dp"
        android:interpolator="@android:interpolator/overshoot"
        android:valueTo="200dp"/>

    <objectAnimator
        android:interpolator="@android:interpolator/linear"
        android:duration="1000"
        android:propertyName="rotation"
        android:valueType="floatType"
        android:valueFrom="0"
        android:valueTo="360"/>

public void btnPropertyMove(View view) {
    //属性动画的加载
    //1. 加载器 加载xml文件
    Animator animator = AnimatorInflater.loadAnimator(this,
            R.animator.animator_move);
    //2. 将需要修改的对象传递给属性动画
    animator.setTarget(mTextView);
    //3. 动画的播放

    animator.start();
}

public void btnPropertyColor(View view) {
    Animator animator = AnimatorInflater.loadAnimator(this, R.animator.animator_color);
    animator.setTarget(mTextView);
    animator.start();
}

public void btnPropertyTextSize(View view) {
    Animator animator = AnimatorInflater.loadAnimator(this, R.animator.animator_textsize);
    animator.setTarget(mTextView);
    animator.start();


}

public void btnPropertyCustom(View view) {
    //自定义对象的属性修改

    //1. 自定义类对象: 确认属性名
    TextShower shower = new TextShower(mTextView);
    //2. 加载xml或者写代码
    Animator animator = AnimatorInflater.loadAnimator(this, R.animator.anmiator_text_show);
    //3. 设置目标
    animator.setTarget(shower);
    animator.start();



}

public void btnPropertyCode(View view) {
    //代码形式的属性动画
    //所有的属性的数值,如果是位置那么以像素为单位
//     ObjectAnimator.ofFloat(mTextView, "translationX", 0, 200).setDuration(2000).start();
    //利用set 可以实现多个属性同时修改

    AnimatorSet set = new AnimatorSet();
    ObjectAnimator animator1 = ObjectAnimator.ofFloat(mTextView, "translationX", 0, 400).setDuration(2000);
    ObjectAnimator animator2 = ObjectAnimator.ofFloat(mTextView, "rotation", 0, 360).setDuration(200);
    set.playTogether(animator1, animator2);
    set.start();

}
```

##### Android M Permission 运行时权限
Permission的保护等级
normal,dangerous,signature,signatureOrSystem.
http://developer.android.com/guide/topics/manifest/permission-element.html

可以总结为:
1.所有的权限都在manifest中声明.
2.如果(1)你的app的targetSdkVersion是23及以上,并且(2)app运行在Android 6.0及以上的设备,危险权限必须动态请求.
当权限被拒绝,app理应还是能够使用的,只不过权限相关的部分功能不能用.
3.上一条中的两个条件(1)(2)没有同时满足,即属于其他情况, 所有权限在安装时请求,如果用户不接受,则不安装.

所有的权限都有自己的permission group.
系统弹框请求某一个permission时也是只说明了它的类别,当用户同意,系统会给予它该条permission.(只有这一条).
但是如果app已经有了该group下的另一条permission,系统将会自动授予权限(也即请求权限的callback直接返回),这过程中不与用户交互.


为什么要及时升级targetSdkVersion?
每一个版本的API有可能会产生新的权限,这些新增的权限, 对于targetSdkVersion比该API低的应用是自动获取的.
所以targetSdkVersion最好是能及时写到最新,这样避免应用自动获取到新API新增的权限.
 
结论: 对targetSdkVersion还不存在的权限是自动获取到的.
https://developer.android.com/guide/topics/security/permissions.html

动态权限请求的实现
1.检查权限状态
if (PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)) {
    //has permission, do operation directly
    ContactsUtils.readPhoneContacts(this);
    Log.i(DEBUG_TAG, "user has the permission already!");
} else {
    //do not have permission
2.动态请求权限
shouldShowRequestPermissionRationale()
如果app之前请求过该权限,被用户拒绝, 这个方法就会返回true.
如果用户之前拒绝权限的时候勾选了对话框中”Don’t ask again”的选项,那么这个方法会返回false.

if (PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_CONTACTS)) {
    //has permission, do operation directly
    ContactsUtils.readPhoneContacts(this);
    Log.i(DEBUG_TAG, "user has the permission already!");
} else {
    //do not have permission
    Log.i(DEBUG_TAG, "user do not have this permission!");

    // Should we show an explanation?
    if (ActivityCompat.shouldShowRequestPermissionRationale(MainActivity.this,
            Manifest.permission.READ_CONTACTS)) {

        // Show an explanation to the user *asynchronously* -- don't block
        // this thread waiting for the user's response! After the user
        // sees the explanation, try again to request the permission.
        Log.i(DEBUG_TAG, "we should explain why we need this permission!");
    } else {

        // No explanation needed, we can request the permission.
        Log.i(DEBUG_TAG, "==request the permission==");

        ActivityCompat.requestPermissions(MainActivity.this,
                new String[]{Manifest.permission.READ_CONTACTS},
                MY_PERMISSIONS_REQUEST_READ_CONTACTS);

        // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an
        // app-defined int constant. The callback method gets the
        // result of the request.
    }
}
3.处理请求权限的响应
当用户对请求权限的dialog做出响应之后,系统会调用onRequestPermissionsResult() 方法,传回用户的响应.
这个回调中request code即为调用requestPermissions()时传入的参数,是app自定义的一个整型值.
@Override
public void onRequestPermissionsResult(int requestCode,
                                       String permissions[], int[] grantResults) {
    switch (requestCode) {
        case MY_PERMISSIONS_REQUEST_READ_CONTACTS: {
            // If request is cancelled, the result arrays are empty.
            if (grantResults.length > 0
                    && grantResults[0] == PackageManager.PERMISSION_GRANTED) {

                // permission was granted, yay! Do the
                // contacts-related task you need to do.
                ContactsUtils.readPhoneContacts(this);
                Log.i(DEBUG_TAG, "user granted the permission!");

            } else {

                // permission denied, boo! Disable the
                // functionality that depends on this permission.
                Log.i(DEBUG_TAG, "user denied the permission!");
            }
            return;
        }

        // other 'case' lines to check for other
        // permissions this app might request
    }
}

Demo地址： https://github.com/mengdd/AndroidMRuntimePermissionSample
 

系统自动回调的情况: 
有一些情形下,调用
1.自动授权: 如果用户已经允许了permission group中的一条A权限,那么当下次调用requestPermissions()方法请求同一个group中的B权限时, 系统会直接调用onRequestPermissionsResult() 回调方法, 并传回PERMISSION_GRANTED的结果.
2.自动拒绝: 如果用户选择了不再询问此条权限,那么app再次调用requestPermissions()方法来请求同一条权限的时候,系统会直接调用onRequestPermissionsResult()回调,返回PERMISSION_DENIED.



可以用ADB命令行来管理权限:
List permissions and status by group:
$ adb shell pm list permissions -d -g

Grant or revoke one or more permissions:
$ adb shell pm [grant|revoke] <permission-name> ... 


##### Notification

> 创建Notification Buider
创建Notification时，可以用NotificationCompat.Builder对象指定Notification的UI内容与行为。一个Builder至少包含以下内容：

一个小的icon，用setSmallIcon()方法设置
一个标题，用setContentTitle()方法设置。
详细的文本，用setContentText()方法设置

- 定义Notification的Action（行为）
尽管在Notification中Actions是可选的，但是你应该至少添加一种Action。
一种Action可以让用户从Notification直接进入你应用内的Activity，在这个activity中他们可以查看引起Notification的事件或者做下一步的处理。
在Notification中，action本身是由PendingIntent定义的，PendingIntent包含了一个启动你应用内Activity的Intent。

如何构建一个PendingIntent取决于你要启动的activity的类型。
当从Notification中启动一个activity时，你必须保存用户的导航体验。
在下面的代码片段中，点击Notification启动一个新的activity，这个activity有效地扩展了Notification的行为。
在这种情形下，就没必要人为地去创建一个返回栈

Intent resultIntent = new Intent(this, ResultActivity.class);

// Because clicking the notification opens a new ("special") activity, there's
// no need to create an artificial back stack.
PendingIntent resultPendingIntent = PendingIntent.getActivity(this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);

- 设置Notification的点击行为
可以通过调用NotificationCompat.Builder中合适的方法，将上一步创建的PendingIntent与一个手势产生关联。
比方说，当点击Notification抽屉里的Notification文本时，启动一个activity，可以通过调用setContentIntent()方法把PendingIntent添加进去。

PendingIntent resultPendingIntent;
...
mBuilder.setContentIntent(resultPendingIntent);

- 发布Notification
为了发布notification：
获取一个NotificationManager实例
使用notify()方法发布Notification。
当你调用notify()方法时，指定一个notification ID。
你可以在以后使用这个ID来更新你的notification。这在Managing Notifications中有更详细的描述。
调用build()方法，会返回一个包含你的特征的Notification对象。

NotificationCompat.Builder mBuilder;
// Sets an ID for the notification
int mNotificationId = 001;
// Gets an instance of the NotificationManager service
NotificationManager mNotifyMgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
// Builds the notification and issues it.
mNotifyMgr.notify(mNotificationId, mBuilder.build());
> 显示Notification进度
Notifications可以包含一个展示用户正在进行的操作状态的动画进度指示器。
如果你可以在任何时候估算这个操作得花多少时间以及当前已经完成多少，你可以用“determinate（确定的，下同）”形式的指示器（一个进度条）。
如果你不能估算这个操作的长度，使用“indeterminate（不确定，下同）”形式的指示器（一个活动的指示器）。

进度指示器用ProgressBar平台实现类来显示。

使用进度指示器，可以调用 setProgress()方法。determinate 与 indeterminate形式将在下面的章节中介绍。
- 展示固定长度的进度指示器
为了展示一个确定长度的进度条，调用 setProgress(max, progress, false)方法将进度条添加进notification，然后发布这个notification
第三个参数是个boolean类型，决定进度条是 indeterminate (true) 还是 determinate (false)。
在你操作进行时，增加progress，更新notification。
在操作结束时，progress应该等于max。
一个常用的调用 setProgress()的方法是设置max为100，然后增加progress就像操作的“完成百分比”。

当操作完成的时候，你可以选择或者让进度条继续展示，或者移除它。
无论哪种情况下，记得更新notification的文字来显示操作完成。
移除进度条，调用setProgress(0, 0, false)方法.比如：

int id = 1;
...
mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
mBuilder = new NotificationCompat.Builder(this);
mBuilder.setContentTitle("Picture Download")
    .setContentText("Download in progress")
    .setSmallIcon(R.drawable.ic_notification);
// Start a lengthy operation in a background thread
new Thread(
    new Runnable() {
        @Override
        public void run() {
            int incr;
            // Do the "lengthy" operation 20 times
            for (incr = 0; incr <= 100; incr+=5) {
                    // Sets the progress indicator to a max value, the
                    // current completion percentage, and "determinate"
                    // state
                    mBuilder.setProgress(100, incr, false);
                    // Displays the progress bar for the first time.
                    mNotifyManager.notify(id, mBuilder.build());
                        // Sleeps the thread, simulating an operation
                        // that takes time
                        try {
                            // Sleep for 5 seconds
                            Thread.sleep(5*1000);
                        } catch (InterruptedException e) {
                            Log.d(TAG, "sleep failure");
                        }
            }
            // When the loop is finished, updates the notification
            mBuilder.setContentText("Download complete")
            // Removes the progress bar
                    .setProgress(0,0,false);
            mNotifyManager.notify(id, mBuilder.build());
        }
    }
// Starts the thread by calling the run() method in its Runnable
).start();
结果notifications显示在图1中，左边是操作正在进行中的notification的快照，右边是操作已经完成的notification的快照。

- 展示持续的活动的指示器
为了展示一个持续的(indeterminate)活动的指示器,用setProgress(0, 0, true)方法把指示器添加进notification，然后发布这个notification
前两个参数忽略，第三个参数决定indicator 还是 indeterminate。结果是指示器与进度条有同样的样式，除了它的动画正在进行。

在操作开始的时候发布notification，动画将会一直进行直到你更新notification。
当操作完成时，调用 setProgress(0, 0, false) 方法，然后更新notification来移除这个动画指示器。
一定要这么做，否责即使你操作完成了，动画还是会在那运行。
同时也要记得更新notification的文字来显示操作完成。

为了观察持续的活动的指示器是如何工作的，看前面的代码。定位到下面的几行：

// Sets an activity indicator for an operation of indeterminate length
mBuilder.setProgress(0, 0, true);
// Issues the notification
mNotifyManager.notify(id, mBuilder.build());

> Notification抽屉Notification抽屉中的Notification主要有两种视觉展示形式，normal view（平常的视图，下同） 与 big view（大视图，下同）。
Notification的 big view样式只有当Notification被扩展时才能出现。
当Notification在Notification抽屉的最上方或者用户点击Notification时才会展现大视图。

Big views在Android4.1被引进的，它不支持老版本设备。

- 设置Notification用来登陆一个新的Activity
这个例子应用用IntentService的子类（PingService）来构造以及发布notification。
在这个代码片段中，IntentService中的方法onHandleIntent() 指定了当用户点击notification时启动一个新的activity。
方法setContentIntent()定义了pending intent在用户点击notification时被激发，因此登陆这个activity.
Intent resultIntent = new Intent(this, ResultActivity.class);
resultIntent.putExtra(CommonConstants.EXTRA_MESSAGE, msg);
resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);

// Because clicking the notification launches a new ("special") activity,
// there's no need to create an artificial back stack.
PendingIntent resultPendingIntent = PendingIntent.getActivity(this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);

// This sets the pending intent that should be fired when the user clicks the
// notification. Clicking the notification launches a new activity.
builder.setContentIntent(resultPendingIntent);

- 构造big view
这个代码片段展示了如何在big view中设置buttons
// Sets up the Snooze and Dismiss action buttons that will appear in the
// big view of the notification.
Intent dismissIntent = new Intent(this, PingService.class);
dismissIntent.setAction(CommonConstants.ACTION_DISMISS);
PendingIntent piDismiss = PendingIntent.getService(this, 0, dismissIntent, 0);

Intent snoozeIntent = new Intent(this, PingService.class);
snoozeIntent.setAction(CommonConstants.ACTION_SNOOZE);
PendingIntent piSnooze = PendingIntent.getService(this, 0, snoozeIntent, 0);

这个代码片段展示了如何构造一个Builder对象，它设置了big view 的样式为"big text",同时设置了它的内容为提醒文字。
它使用addAction()方法来添加将要在big view中出现的Snooze与Dismiss按钮（以及它们相关联的pending intents).
// Constructs the Builder object.
NotificationCompat.Builder builder = new NotificationCompat.Builder(this)
        .setSmallIcon(R.drawable.ic_stat_notification)
        .setContentTitle(getString(R.string.notification))
        .setContentText(getString(R.string.ping))
        .setDefaults(Notification.DEFAULT_ALL) // requires VIBRATE permission
        /*
         * Sets the big view "big text" style and supplies the
         * text (the user's reminder message) that will be displayed
         * in the detail area of the expanded notification.
         * These calls are ignored by the support library for
         * pre-4.1 devices.
         */
        .setStyle(new NotificationCompat.BigTextStyle().bigText(msg))
        .addAction (R.drawable.ic_stat_dismiss, getString(R.string.dismiss), piDismiss)
        .addAction (R.drawable.ic_stat_snooze, getString(R.string.snooze), piSnooze);


> 更新Notification
当你需要对同一事件发布多次Notification时，你应该避免每次都生成一个全新的Notification。
相反，你应该考虑去更新先前的Notification，或者改变它的值，或者增加一些值，或者两者同时进行。

- 改变一个Notification
想要设置一个可以被更新的Notification，需要在发布它的时候调用NotificationManager.notify(ID, notification)方法为它指定一个notification ID。更新一个已经发布的Notification，需要更新或者创建一个NotificationCompat.Builder对象，并从这个对象创建一个Notification对象，然后用与先前一样的ID去发布这个Notification。

下面的代码片段演示了更新一个notification来反映事件发生的次数，它把notification堆积起来，显示一个总数。
```bash
mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
// Sets an ID for the notification, so it can be updated
int notifyID = 1;
mNotifyBuilder = new NotificationCompat.Builder(this)
    .setContentTitle("New Message")
    .setContentText("You've received new messages.")
    .setSmallIcon(R.drawable.ic_notify_status)
numMessages = 0;
// Start of a loop that processes data and then notifies the user
...
    mNotifyBuilder.setContentText(currentText)
        .setNumber(++numMessages);
    // Because the ID remains unchanged, the existing notification is
    // updated.
    mNotificationManager.notify(notifyID, mNotifyBuilder.build());
...
```
- 移除Notification

Notifications 将持续可见，除非下面任何一种情况发生。

用户清除Notification单独地或者使用“清除所有”（如果Notification能被清除）。
你在创建notification时调用了 setAutoCancel(boolean)方法，以及用户点击了这个notification，
你为一个指定的 notification ID调用了cancel()方法。这个方法也会删除正在进行的notifications。
你调用了cancelAll()方法，它将会移除你先前发布的所有Notification。

##### 为App内容开启深度链接
为使Google能够抓取你的app内容，并允许用户从搜索结果进入你的app，你必须给你的app manifest中相关的activity添加intent filter。这些intent filter能使深度链接与你的任何activity相连。例如，用户可以在购物app中，点击一条深度链接来浏览一个介绍了自己所搜索的产品的页面。

##为你的深度链接添加Intent filter

要创建一条与你的app内容相连的深度链接，添加一个包含了以下这些元素和属性值的intent filter到你的manifest中:

<action>

指定ACTION_VIEW的操作，使得Google搜索可以触及intent filter。

<data>

添加一个或多个<data>标签，每一个标签代表一种activity对URI格式的解析，<data>必须至少包含android:scheme属性。

你可以添加额外的属性来改善activity所接受的URI类型。例如，你或许有几个activity可以接受相似的URI，它们仅仅是路径名不同。在这种情况下，使用android:path属性或它的变形(pathPattern或pathPrefix)，使系统能辨别对不同的URI路径应该启动哪个activity。

<category>

包括BROWSABLE category。BROWSABLE category对于使intent filter能被浏览器访问是必要的。
没有这个category，在浏览器中点击链接无法解析到你的app。
DEFAULT category是可选的，但建议添加。没有这个category，activity只能够使用app组件名称以显示(explicit)intent启动。

下面的一段XML代码向你展示，你应该如何在manifest中为深度链接指定一个intent filter。
URI “example://gizmos” 和 “http://www.example.com/gizmos” 都能够解析到这个activity。

<activity
    android:name="com.example.android.GizmosActivity"
    android:label="@string/title_gizmos" >
    <intent-filter android:label="@string/filter_title_viewgizmos">
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />
        <!-- 接受以"example://gizmos”开头的 URIs  -->
        <data android:scheme="example"
              android:host="gizmos" />
        <!-- 接受以"http://www.example.com/gizmos”开头的 URIs  -->
        <data android:scheme="http"
              android:host="www.example.com"
              android:pathPrefix="gizmos" />
    </intent-filter>
</activity>
当你把包含有指定activity内容的URI的intent filter添加到你的app manifest后，Android就可以在你的app运行时，为app与匹配URI的Intent建立路径。


##从传入的意图读取数据

一旦系统通过一个intent filter启动你的activity，你可以使用由Intent提供的数据来决定需要处理什么。
调用getData()和getAction()方法来取出传入Intent中的数据与操作。
你可以在activity生命周期的任何时候调用这些方法，但一般情况下你应该在前期回调中调用如onCreate()或onStart()。

这个是一段代码，展示如何从Intent中取出数据:

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    Intent intent = getIntent();
    String action = intent.getAction();
    Uri data = intent.getData();
}
遵守下面这些惯例来提高用户体验:

深度链接应直接为用户打开内容，不需要任何提示，插播式广告页和登录页面。

要确保用户能看到app的内容，即使之前从没打开过这个应用。
当用户从启动器打开app时，可以在操作结束后给出提示。这个准则也同样适用于网站的first click free体验。

遵循Navigation with Back and Up中的设计指导，来使你的app能够满足用户通过深度链接进入app后，向后导航的需求。

##测试你的深度链接

你可以使用Android Debug Bridge和activity管理(am)工具来测试你指定的intent filter URI，能否正确解析到正确的app activity。
你可以在设备或者模拟器上运行adb命令。

测试intent filter URI的一般adb语法是:

$ adb shell am start
    -W -a android.intent.action.VIEW
    -d <URI> <PACKAGE>
例如，下面的命令视图浏览与指定URI相关的目标app activity。

$ adb shell am start
    -W -a android.intent.action.VIEW
    -d "example://gizmos" com.example.android


##### 为索引指定App内容
Google的网页爬虫机器(Googlebot)会抓取页面，并为Google搜索引擎建立索引，也能为你的Android app内容建立索引。
通过选择加入这一功能，你可以允许Googlebot通过抓取在Google Play Store中的APK内容，为你的app内容建立索引。
要指出哪些app内容你想被Google索引，只需要添加链接元素到现有的Sitemap文件，或添加到你的网站中每个页面的<head>元素中，以相同的方式为你的页面添加。

Note:现在，Google搜索app索引功能从以前只限于英文Android app，转变为开放给参与了早期开放计划(early adopter program)的所有开发者。
你可以通过提交App Indexing Expression of Interest表格来注册成为参与者。

```bash

你所共享给Google搜索的深度链接必须按照下面的URI格式:
android-app://<package_name>/<scheme>/<host_path>
构成URI的各部分是:

package_name 代表在Google Play Developer Console中所列出来的你的APK的包名。

scheme 匹配你的intent filter的URI方案。

host_path 找出你的应用中所指定的内容。

下面的几节叙述如何添加一个深度链接URI到你的Sitemap或网页中。

添加深度链接(Deep link)到你的Sitemap

要在你的Sitemap中为Google搜索app索引(Google Search app indexing)添加深度链接的注解，使用<xhtml:link>标签，并指定用作替代URI的深度链接。

例如，下面一段XML代码向你展示如何使用<loc>标签指定一个链接到你的页面的链接，以及如何使用<xhtml:link>标签指定链接到你的Android app的深度链接。

<?xml version="1.0" encoding="UTF-8" ?>
<urlset
    xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
    xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <url>
        <loc>example://gizmos</loc>
        <xhtml:link rel="alternate" href="android-app://com.example.android/example/gizmos" />
    </url>
    ...
</urlset>
##添加深度链接到你的网页中

除了在你的Sitemap文件中，为Google搜索app索引指定深度链接外，你还可以在你的HTML标记网页中给深度链接添加注解。
你可以在<head>标签内这么做，为每一个页面添加一个<link>标签，并指定用作替代URI的深度链接。

例如，下面的一段HTML代码向你展示如何在页面中指定一个URL为example://gizmos的相应的深度链接。

<html>
<head>
    <link rel="alternate" href="android-app://com.example.android/example/gizmos" />
    ...
</head>
<body> ... </body>
##允许Google通过你的app抓取URL请求

一般来说，你可以通过使用robots.txt文件，来控制Googlebot如何抓取你网站上的公开访问的URL。
当Googlebot为你的app内容建立索引后，你的app可以把HTTP请求当做一般操作。
但是，这些请求会被视为从Googlebot发出，发送到你的服务器上。因此，你必须正确配置你的服务器上的robots.txt文件来允许这些请求。

例如，下面的robots.txt指示向你展示，如何允许你网站上的特定目录(如 /api/ )能被你的app访问，并限制Googlebot访问你的网站上的其他目录。

User-Agent: Googlebot
Allow: /api/
Disallow: /
学习更多关于如何修改robots.txt，来控制页面抓取，详见Controlling Crawling and Indexing Getting Started。
https://developers.google.com/webmasters/control-crawl-index/docs/getting_started
```

##### RecyclerView ListView
缓存机制对比：
ListView： mActivieViews mScrapViews
RecyclerView: mAttachedScrap mCacheViews mViewCacheExtension mRecyclerPool

ListView和RecyclerView缓存机制基本一致：
1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView；
2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用.
3). RecyclerView的优势在于
a.mCacheViews的使用，可以做到屏幕外的列表项ItemView进入屏幕内时也无须bindView快速重用；
b.mRecyclerPool可以供多个RecyclerView共同使用，在特定场景下，如viewpaper+多个列表页下有优势.
客观来说，RecyclerView在特定场景下对ListView的缓存机制做了补强和完善。

缓存不同：
RecyclerView缓存RecyclerView.ViewHolder，抽象可理解为： View + ViewHolder(避免每次createView时调用findViewById) + flag(标识状态)；
ListView缓存View。

获取缓存的流程：
RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView：
而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView），相关代码如下：


ListView中通过pos获取的是view，即pos–>view；
RecyclerView中通过pos获取的是viewholder，即pos –> (view，viewHolder，flag)；
标志flag的作用是判断view是否需要重新bindView，这也是RecyclerView实现局部刷新的一个核心.


局部刷新:
RecyclerView更大的亮点在于提供了局部刷新的接口，通过局部刷新，就能避免调用许多无用的bindView.

notifyItemRemoved(1)为例，最终会调用requestLayout()，使整个RecyclerView重新绘制，
过程为： onMeasure()–>onLayout()–>onDraw()
其中，onLayout()为重点，分为三步： 
1. dispathLayoutStep1()：记录RecyclerView刷新前列表项ItemView的各种信息，如Top,Left,Bottom,Right，用于动画的相关计算； 
2. dispathLayoutStep2()：真正测量布局大小，位置，核心函数为layoutChildren()； 
3. dispathLayoutStep3()：计算布局前后各个ItemView的状态，如Remove，Add，Move，Update等，如有必要执行相应的动画.


列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView,更加强大完善，易扩展
其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。


##### TabLayout
通常在ViewPager的上方，我们都会放一个标签指示器与ViewPager进行联动。以前，我们大多使用的是GitHub上的开源框架PagerSlidingTabTrip
而现在，我们可以使用Android自带的控件TabLayout来实现这个效果了，而且TabLayout更为强大，因为Tab标签可以使用自定义View。

添加support:design支持库
compile "com.android.support:design+"

<android.support.design.widget.TabLayout
        android:id="@+id/timeline_tablayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

<android.support.v4.view.ViewPager
        android:id="@+id/timeline_viewpager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

创建显示TabLayout中每一个Tab的Fragment。
创建ViewPager的适配器Adapter extends FragmentPagerAdapter:

将TabLayout、ViewPager以及Adapter关联起来
mViewPager.setAdapter(mAdapter);
mTabLayout.setupWithViewPager(mViewPager)

TabLayout 默认使用 adapter getPageTitle方法获取标题（PagerSlidingTabTrip同理）。
复写getPageTitle方法时使用SpannableString标放置在ImageSpan中

drawable = ContextCompat.getDrawable(mContext, R.drawable.icon_weibo_timeline_public);
drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
ImageSpan imageSpan = new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM);
SpannableString spannableString = new SpannableString(" " + " wo de ");
spannableString.setSpan(imageSpan, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
（使用imagespan时 务必 将 textAllCaps: false）

##### ConstraintLayout
ConstraintLayout 翻译为 约束布局，也有人把它称作 增强型的相对布局，由 2016 年 Google I/O 推出。扁平式的布局方式，无任何嵌套，减少布局的层级，优化渲染性能。从支持力度而言，将成为主流布局样式，完全代替其他布局。


##### 图片加载
一个MeasureSpec由大小和模式组成。它有三种模式：
UNSPECIFIED(未指定),父元素不对子元素施加任何束缚，子元素可以得到任意想要的大小；
EXACTLY(完全)，父元素决定子元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；
AT_MOST(至多)，子元素至多达到指定大小的值。
1.static int getMode(int measureSpec):根据提供的测量值(格式)提取模式(上述三个模式之一)

2.static int getSize(int measureSpec):根据提供的测量值(格式)提取大小值(这个大小也就是我们通常所说的大小)

3.static int makeMeasureSpec(int size,int mode):根据提供的大小值和模式创建一个测量值(格式)


